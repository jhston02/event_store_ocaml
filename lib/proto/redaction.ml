(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: redaction.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Shared = Shared
end
(**/**)
module Event_store = struct
  module Client = struct
    module Redaction = struct
      module rec GetEventPositionReq : sig
        val name': unit -> string
        type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int } 
        val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?stream_revision:int -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "redaction.event_store.client.redaction.GetEventPositionReq"
        type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int }
        let make =
          fun ?stream_identifier ?stream_revision () -> 
          let stream_revision = match stream_revision with Some v -> v | None -> 0 in
          { stream_identifier; stream_revision }
        
        let to_proto =
          let apply = fun ~f:f' { stream_identifier; stream_revision } -> f' [] stream_identifier stream_revision in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions stream_identifier stream_revision -> { stream_identifier; stream_revision } in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and GetEventPositionResp : sig
        val name': unit -> string
        type t = EventPosition.t list 
        val make : ?event_positions:EventPosition.t list -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "redaction.event_store.client.redaction.GetEventPositionResp"
        type t = EventPosition.t list
        let make =
          fun ?event_positions () -> 
          let event_positions = match event_positions with Some v -> v | None -> [] in
          event_positions
        
        let to_proto =
          let apply = fun ~f:f' event_positions -> f' [] event_positions in
          let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> EventPosition.to_proto t)), not_packed) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions event_positions -> event_positions in
          let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> EventPosition.from_proto t)), not_packed) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and EventPosition : sig
        val name': unit -> string
        type t = { log_position: int; chunk_info: ChunkInfo.t option } 
        val make : ?log_position:int -> ?chunk_info:ChunkInfo.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "redaction.event_store.client.redaction.EventPosition"
        type t = { log_position: int; chunk_info: ChunkInfo.t option }
        let make =
          fun ?log_position ?chunk_info () -> 
          let log_position = match log_position with Some v -> v | None -> 0 in
          { log_position; chunk_info }
        
        let to_proto =
          let apply = fun ~f:f' { log_position; chunk_info } -> f' [] log_position chunk_info in
          let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic_opt (2, (message (fun t -> ChunkInfo.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions log_position chunk_info -> { log_position; chunk_info } in
          let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic_opt (2, (message (fun t -> ChunkInfo.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ChunkInfo : sig
        val name': unit -> string
        type t = { file_name: string; version: int; is_complete: bool; event_offset: int } 
        val make : ?file_name:string -> ?version:int -> ?is_complete:bool -> ?event_offset:int -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "redaction.event_store.client.redaction.ChunkInfo"
        type t = { file_name: string; version: int; is_complete: bool; event_offset: int }
        let make =
          fun ?file_name ?version ?is_complete ?event_offset () -> 
          let file_name = match file_name with Some v -> v | None -> {||} in
          let version = match version with Some v -> v | None -> 0 in
          let is_complete = match is_complete with Some v -> v | None -> false in
          let event_offset = match event_offset with Some v -> v | None -> 0 in
          { file_name; version; is_complete; event_offset }
        
        let to_proto =
          let apply = fun ~f:f' { file_name; version; is_complete; event_offset } -> f' [] file_name version is_complete event_offset in
          let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, uint32_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, uint32_int, proto3) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions file_name version is_complete event_offset -> { file_name; version; is_complete; event_offset } in
          let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, uint32_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, uint32_int, proto3) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and SwitchChunkReq : sig
        val name': unit -> string
        type t = { target_chunk_file: string; new_chunk_file: string } 
        val make : ?target_chunk_file:string -> ?new_chunk_file:string -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "redaction.event_store.client.redaction.SwitchChunkReq"
        type t = { target_chunk_file: string; new_chunk_file: string }
        let make =
          fun ?target_chunk_file ?new_chunk_file () -> 
          let target_chunk_file = match target_chunk_file with Some v -> v | None -> {||} in
          let new_chunk_file = match new_chunk_file with Some v -> v | None -> {||} in
          { target_chunk_file; new_chunk_file }
        
        let to_proto =
          let apply = fun ~f:f' { target_chunk_file; new_chunk_file } -> f' [] target_chunk_file new_chunk_file in
          let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions target_chunk_file new_chunk_file -> { target_chunk_file; new_chunk_file } in
          let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and SwitchChunkResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "redaction.event_store.client.redaction.SwitchChunkResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      module Redaction = struct
        module GetEventPositions = struct
          let package_name = Some "event_store.client.redaction"
          let service_name = "Redaction"
          let method_name = "GetEventPositions"
          let name = "/event_store.client.redaction.Redaction/GetEventPositions"
          module Request = GetEventPositionReq
          module Response = GetEventPositionResp
        end
        let getEventPositions = 
          (module GetEventPositionReq : Runtime'.Service.Message with type t = GetEventPositionReq.t ), 
          (module GetEventPositionResp : Runtime'.Service.Message with type t = GetEventPositionResp.t )
        
        module SwitchChunks = struct
          let package_name = Some "event_store.client.redaction"
          let service_name = "Redaction"
          let method_name = "SwitchChunks"
          let name = "/event_store.client.redaction.Redaction/SwitchChunks"
          module Request = SwitchChunkReq
          module Response = SwitchChunkResp
        end
        let switchChunks = 
          (module SwitchChunkReq : Runtime'.Service.Message with type t = SwitchChunkReq.t ), 
          (module SwitchChunkResp : Runtime'.Service.Message with type t = SwitchChunkResp.t )
        
      end
    end
  end
end