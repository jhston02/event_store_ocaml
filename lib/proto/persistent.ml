(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: persistent.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Shared = Shared
end
(**/**)
module Event_store = struct
  module Client = struct
    module Persistent_subscriptions = struct
      module rec ReadReq : sig
        module rec Options : sig
          module rec UUIDOption : sig
            val name': unit -> string
            type t = [ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] 
            val make : ?content:[ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; group_name: string; buffer_size: int; uuid_option: ReadReq.Options.UUIDOption.t option } 
          val make : ?stream_option:[ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?group_name:string -> ?buffer_size:int -> ?uuid_option:ReadReq.Options.UUIDOption.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and Ack : sig
          val name': unit -> string
          type t = { id: bytes; ids: Imported'modules.Shared.Event_store.Client.UUID.t list } 
          val make : ?id:bytes -> ?ids:Imported'modules.Shared.Event_store.Client.UUID.t list -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and Nack : sig
          module rec Action : sig
            type t = Unknown | Park | Retry | Skip | Stop 
            val to_int: t -> int
            val from_int: int -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { id: bytes; ids: Imported'modules.Shared.Event_store.Client.UUID.t list; action: ReadReq.Nack.Action.t; reason: string } 
          val make : ?id:bytes -> ?ids:Imported'modules.Shared.Event_store.Client.UUID.t list -> ?action:ReadReq.Nack.Action.t -> ?reason:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = [ `not_set | `Options of ReadReq.Options.t | `Ack of ReadReq.Ack.t | `Nack of ReadReq.Nack.t ] 
        val make : ?content:[ `not_set | `Options of ReadReq.Options.t | `Ack of ReadReq.Ack.t | `Nack of ReadReq.Nack.t ] -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          module rec UUIDOption : sig
            val name': unit -> string
            type t = [ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] 
            val make : ?content:[ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; group_name: string; buffer_size: int; uuid_option: ReadReq.Options.UUIDOption.t option } 
          val make : ?stream_option:[ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?group_name:string -> ?buffer_size:int -> ?uuid_option:ReadReq.Options.UUIDOption.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec UUIDOption : sig
            val name': unit -> string
            type t = [ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] 
            val make : ?content:[ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "persistent.event_store.client.persistent_subscriptions.ReadReq.Options.UUIDOption"
            type t = [ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ]
            let make =
              fun ?content () -> 
              let content = match content with Some v -> v | None -> `not_set in
              content
            
            let to_proto =
              let apply = fun ~f:f' content -> f' [] content in
              let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Structured v -> oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `String v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions content -> content in
              let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Structured v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `String v) ]) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          let name' () = "persistent.event_store.client.persistent_subscriptions.ReadReq.Options"
          type t = { stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; group_name: string; buffer_size: int; uuid_option: ReadReq.Options.UUIDOption.t option }
          let make =
            fun ?stream_option ?group_name ?buffer_size ?uuid_option () -> 
            let stream_option = match stream_option with Some v -> v | None -> `not_set in
            let group_name = match group_name with Some v -> v | None -> {||} in
            let buffer_size = match buffer_size with Some v -> v | None -> 0 in
            { stream_option; group_name; buffer_size; uuid_option }
          
          let to_proto =
            let apply = fun ~f:f' { stream_option; group_name; buffer_size; uuid_option } -> f' [] stream_option group_name buffer_size uuid_option in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream_identifier v -> oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t)), v) | `All v -> oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: basic (2, string, proto3) ^:: basic (3, int32_int, proto3) ^:: basic_opt (4, (message (fun t -> ReadReq.Options.UUIDOption.to_proto t))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_option group_name buffer_size uuid_option -> { stream_option; group_name; buffer_size; uuid_option } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t)), fun v -> `Stream_identifier v); oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `All v) ]) ^:: basic (2, string, proto3) ^:: basic (3, int32_int, proto3) ^:: basic_opt (4, (message (fun t -> ReadReq.Options.UUIDOption.from_proto t))) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and Ack : sig
          val name': unit -> string
          type t = { id: bytes; ids: Imported'modules.Shared.Event_store.Client.UUID.t list } 
          val make : ?id:bytes -> ?ids:Imported'modules.Shared.Event_store.Client.UUID.t list -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.ReadReq.Ack"
          type t = { id: bytes; ids: Imported'modules.Shared.Event_store.Client.UUID.t list }
          let make =
            fun ?id ?ids () -> 
            let id = match id with Some v -> v | None -> (Bytes.of_string {||}) in
            let ids = match ids with Some v -> v | None -> [] in
            { id; ids }
          
          let to_proto =
            let apply = fun ~f:f' { id; ids } -> f' [] id ids in
            let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: repeated (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t)), not_packed) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions id ids -> { id; ids } in
            let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: repeated (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t)), not_packed) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and Nack : sig
          module rec Action : sig
            type t = Unknown | Park | Retry | Skip | Stop 
            val to_int: t -> int
            val from_int: int -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { id: bytes; ids: Imported'modules.Shared.Event_store.Client.UUID.t list; action: ReadReq.Nack.Action.t; reason: string } 
          val make : ?id:bytes -> ?ids:Imported'modules.Shared.Event_store.Client.UUID.t list -> ?action:ReadReq.Nack.Action.t -> ?reason:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec Action : sig
            type t = Unknown | Park | Retry | Skip | Stop 
            val to_int: t -> int
            val from_int: int -> (t, [> Runtime'.Result.error]) result
          end = struct 
            type t = Unknown | Park | Retry | Skip | Stop 
            let to_int = function
              | Unknown -> 0
              | Park -> 1
              | Retry -> 2
              | Skip -> 3
              | Stop -> 4
            
            let from_int = function
              | 0 -> Ok Unknown
              | 1 -> Ok Park
              | 2 -> Ok Retry
              | 3 -> Ok Skip
              | 4 -> Ok Stop
              | n -> Error (`Unknown_enum_value n)
            
          end
          let name' () = "persistent.event_store.client.persistent_subscriptions.ReadReq.Nack"
          type t = { id: bytes; ids: Imported'modules.Shared.Event_store.Client.UUID.t list; action: ReadReq.Nack.Action.t; reason: string }
          let make =
            fun ?id ?ids ?action ?reason () -> 
            let id = match id with Some v -> v | None -> (Bytes.of_string {||}) in
            let ids = match ids with Some v -> v | None -> [] in
            let action = match action with Some v -> v | None -> (ReadReq.Nack.Action.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
            let reason = match reason with Some v -> v | None -> {||} in
            { id; ids; action; reason }
          
          let to_proto =
            let apply = fun ~f:f' { id; ids; action; reason } -> f' [] id ids action reason in
            let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: repeated (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t)), not_packed) ^:: basic (3, (enum ReadReq.Nack.Action.to_int), proto3) ^:: basic (4, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions id ids action reason -> { id; ids; action; reason } in
            let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: repeated (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t)), not_packed) ^:: basic (3, (enum ReadReq.Nack.Action.from_int), proto3) ^:: basic (4, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "persistent.event_store.client.persistent_subscriptions.ReadReq"
        type t = [ `not_set | `Options of ReadReq.Options.t | `Ack of ReadReq.Ack.t | `Nack of ReadReq.Nack.t ]
        let make =
          fun ?content () -> 
          let content = match content with Some v -> v | None -> `not_set in
          content
        
        let to_proto =
          let apply = fun ~f:f' content -> f' [] content in
          let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Options v -> oneof_elem (1, (message (fun t -> ReadReq.Options.to_proto t)), v) | `Ack v -> oneof_elem (2, (message (fun t -> ReadReq.Ack.to_proto t)), v) | `Nack v -> oneof_elem (3, (message (fun t -> ReadReq.Nack.to_proto t)), v))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions content -> content in
          let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> ReadReq.Options.from_proto t)), fun v -> `Options v); oneof_elem (2, (message (fun t -> ReadReq.Ack.from_proto t)), fun v -> `Ack v); oneof_elem (3, (message (fun t -> ReadReq.Nack.from_proto t)), fun v -> `Nack v) ]) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ReadResp : sig
        module rec ReadEvent : sig
          module rec RecordedEvent : sig
            module rec MetadataEntry : sig
              val name': unit -> string
              type t = (string * string) 
              val make : ?key:string -> ?value:string -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int; prepare_position: int; commit_position: int; metadata: ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
            val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?stream_revision:int -> ?prepare_position:int -> ?commit_position:int -> ?metadata:ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { event: ReadResp.ReadEvent.RecordedEvent.t option; link: ReadResp.ReadEvent.RecordedEvent.t option; position: [ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ]; count: [ `not_set | `Retry_count of int | `No_retry_count of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?event:ReadResp.ReadEvent.RecordedEvent.t -> ?link:ReadResp.ReadEvent.RecordedEvent.t -> ?position:[ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?count:[ `not_set | `Retry_count of int | `No_retry_count of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and SubscriptionConfirmation : sig
          val name': unit -> string
          type t = string 
          val make : ?subscription_id:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = [ `not_set | `Event of ReadResp.ReadEvent.t | `Subscription_confirmation of ReadResp.SubscriptionConfirmation.t ] 
        val make : ?content:[ `not_set | `Event of ReadResp.ReadEvent.t | `Subscription_confirmation of ReadResp.SubscriptionConfirmation.t ] -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec ReadEvent : sig
          module rec RecordedEvent : sig
            module rec MetadataEntry : sig
              val name': unit -> string
              type t = (string * string) 
              val make : ?key:string -> ?value:string -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int; prepare_position: int; commit_position: int; metadata: ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
            val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?stream_revision:int -> ?prepare_position:int -> ?commit_position:int -> ?metadata:ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { event: ReadResp.ReadEvent.RecordedEvent.t option; link: ReadResp.ReadEvent.RecordedEvent.t option; position: [ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ]; count: [ `not_set | `Retry_count of int | `No_retry_count of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?event:ReadResp.ReadEvent.RecordedEvent.t -> ?link:ReadResp.ReadEvent.RecordedEvent.t -> ?position:[ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?count:[ `not_set | `Retry_count of int | `No_retry_count of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec RecordedEvent : sig
            module rec MetadataEntry : sig
              val name': unit -> string
              type t = (string * string) 
              val make : ?key:string -> ?value:string -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int; prepare_position: int; commit_position: int; metadata: ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
            val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?stream_revision:int -> ?prepare_position:int -> ?commit_position:int -> ?metadata:ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            module rec MetadataEntry : sig
              val name': unit -> string
              type t = (string * string) 
              val make : ?key:string -> ?value:string -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end = struct 
              let name' () = "persistent.event_store.client.persistent_subscriptions.ReadResp.ReadEvent.RecordedEvent.MetadataEntry"
              type t = (string * string)
              let make =
                fun ?key ?value () -> 
                let key = match key with Some v -> v | None -> {||} in
                let value = match value with Some v -> v | None -> {||} in
                (key, value)
              
              let to_proto =
                let apply = fun ~f:f' (key, value) -> f' [] key value in
                let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
                let serialize = Runtime'.Serialize.serialize [] (spec) in
                fun t -> apply ~f:serialize t
              
              let from_proto =
                let constructor = fun _extensions key value -> (key, value) in
                let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
                let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
                fun writer -> deserialize writer |> Runtime'.Result.open_error
              
            end
            let name' () = "persistent.event_store.client.persistent_subscriptions.ReadResp.ReadEvent.RecordedEvent"
            type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int; prepare_position: int; commit_position: int; metadata: ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list; custom_metadata: bytes; data: bytes }
            let make =
              fun ?id ?stream_identifier ?stream_revision ?prepare_position ?commit_position ?metadata ?custom_metadata ?data () -> 
              let stream_revision = match stream_revision with Some v -> v | None -> 0 in
              let prepare_position = match prepare_position with Some v -> v | None -> 0 in
              let commit_position = match commit_position with Some v -> v | None -> 0 in
              let metadata = match metadata with Some v -> v | None -> [] in
              let custom_metadata = match custom_metadata with Some v -> v | None -> (Bytes.of_string {||}) in
              let data = match data with Some v -> v | None -> (Bytes.of_string {||}) in
              { id; stream_identifier; stream_revision; prepare_position; commit_position; metadata; custom_metadata; data }
            
            let to_proto =
              let apply = fun ~f:f' { id; stream_identifier; stream_revision; prepare_position; commit_position; metadata; custom_metadata; data } -> f' [] id stream_identifier stream_revision prepare_position commit_position metadata custom_metadata data in
              let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: basic (3, uint64_int, proto3) ^:: basic (4, uint64_int, proto3) ^:: basic (5, uint64_int, proto3) ^:: repeated (6, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.MetadataEntry.to_proto t)), not_packed) ^:: basic (7, bytes, proto3) ^:: basic (8, bytes, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions id stream_identifier stream_revision prepare_position commit_position metadata custom_metadata data -> { id; stream_identifier; stream_revision; prepare_position; commit_position; metadata; custom_metadata; data } in
              let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: basic (3, uint64_int, proto3) ^:: basic (4, uint64_int, proto3) ^:: basic (5, uint64_int, proto3) ^:: repeated (6, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.MetadataEntry.from_proto t)), not_packed) ^:: basic (7, bytes, proto3) ^:: basic (8, bytes, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          let name' () = "persistent.event_store.client.persistent_subscriptions.ReadResp.ReadEvent"
          type t = { event: ReadResp.ReadEvent.RecordedEvent.t option; link: ReadResp.ReadEvent.RecordedEvent.t option; position: [ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ]; count: [ `not_set | `Retry_count of int | `No_retry_count of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?event ?link ?position ?count () -> 
            let position = match position with Some v -> v | None -> `not_set in
            let count = match count with Some v -> v | None -> `not_set in
            { event; link; position; count }
          
          let to_proto =
            let apply = fun ~f:f' { event; link; position; count } -> f' [] event link position count in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.to_proto t))) ^:: basic_opt (2, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Commit_position v -> oneof_elem (3, uint64_int, v) | `No_position v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Retry_count v -> oneof_elem (5, int32_int, v) | `No_retry_count v -> oneof_elem (6, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions event link position count -> { event; link; position; count } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.from_proto t))) ^:: basic_opt (2, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.from_proto t))) ^:: oneof ([ oneof_elem (3, uint64_int, fun v -> `Commit_position v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_position v) ]) ^:: oneof ([ oneof_elem (5, int32_int, fun v -> `Retry_count v); oneof_elem (6, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_retry_count v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and SubscriptionConfirmation : sig
          val name': unit -> string
          type t = string 
          val make : ?subscription_id:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.ReadResp.SubscriptionConfirmation"
          type t = string
          let make =
            fun ?subscription_id () -> 
            let subscription_id = match subscription_id with Some v -> v | None -> {||} in
            subscription_id
          
          let to_proto =
            let apply = fun ~f:f' subscription_id -> f' [] subscription_id in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions subscription_id -> subscription_id in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "persistent.event_store.client.persistent_subscriptions.ReadResp"
        type t = [ `not_set | `Event of ReadResp.ReadEvent.t | `Subscription_confirmation of ReadResp.SubscriptionConfirmation.t ]
        let make =
          fun ?content () -> 
          let content = match content with Some v -> v | None -> `not_set in
          content
        
        let to_proto =
          let apply = fun ~f:f' content -> f' [] content in
          let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Event v -> oneof_elem (1, (message (fun t -> ReadResp.ReadEvent.to_proto t)), v) | `Subscription_confirmation v -> oneof_elem (2, (message (fun t -> ReadResp.SubscriptionConfirmation.to_proto t)), v))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions content -> content in
          let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> ReadResp.ReadEvent.from_proto t)), fun v -> `Event v); oneof_elem (2, (message (fun t -> ReadResp.SubscriptionConfirmation.from_proto t)), fun v -> `Subscription_confirmation v) ]) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and CreateReq : sig
        module rec ConsumerStrategy : sig
          type t = DispatchToSingle | RoundRobin | Pinned 
          val to_int: t -> int
          val from_int: int -> (t, [> Runtime'.Result.error]) result
        end
        and Options : sig
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream of CreateReq.StreamOptions.t | `All of CreateReq.AllOptions.t ]; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; group_name: string; settings: CreateReq.Settings.t option } 
          val make : ?stream_option:[ `not_set | `Stream of CreateReq.StreamOptions.t | `All of CreateReq.AllOptions.t ] -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?group_name:string -> ?settings:CreateReq.Settings.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and StreamOptions : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?revision_option:[ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and AllOptions : sig
          module rec FilterOptions : sig
            module rec Expression : sig
              val name': unit -> string
              type t = { regex: string; prefix: string list } 
              val make : ?regex:string -> ?prefix:string list -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { filter: [ `not_set | `Stream_identifier of CreateReq.AllOptions.FilterOptions.Expression.t | `Event_type of CreateReq.AllOptions.FilterOptions.Expression.t ]; window: [ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ]; checkpointIntervalMultiplier: int } 
            val make : ?filter:[ `not_set | `Stream_identifier of CreateReq.AllOptions.FilterOptions.Expression.t | `Event_type of CreateReq.AllOptions.FilterOptions.Expression.t ] -> ?window:[ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?checkpointIntervalMultiplier:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { all_option: [ `not_set | `Position of CreateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ]; filter_option: [ `not_set | `Filter of CreateReq.AllOptions.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?all_option:[ `not_set | `Position of CreateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?filter_option:[ `not_set | `Filter of CreateReq.AllOptions.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and Settings : sig
          val name': unit -> string
          type t = { resolve_links: bool; revision: int; extra_statistics: bool; max_retry_count: int; min_checkpoint_count: int; max_checkpoint_count: int; max_subscriber_count: int; live_buffer_size: int; read_batch_size: int; history_buffer_size: int; named_consumer_strategy: CreateReq.ConsumerStrategy.t; message_timeout: [ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ]; checkpoint_after: [ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ]; consumer_strategy: string } 
          val make : ?resolve_links:bool -> ?revision:int -> ?extra_statistics:bool -> ?max_retry_count:int -> ?min_checkpoint_count:int -> ?max_checkpoint_count:int -> ?max_subscriber_count:int -> ?live_buffer_size:int -> ?read_batch_size:int -> ?history_buffer_size:int -> ?named_consumer_strategy:CreateReq.ConsumerStrategy.t -> ?message_timeout:[ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ] -> ?checkpoint_after:[ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ] -> ?consumer_strategy:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = CreateReq.Options.t option 
        val make : ?options:CreateReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec ConsumerStrategy : sig
          type t = DispatchToSingle | RoundRobin | Pinned 
          val to_int: t -> int
          val from_int: int -> (t, [> Runtime'.Result.error]) result
        end = struct 
          type t = DispatchToSingle | RoundRobin | Pinned 
          let to_int = function
            | DispatchToSingle -> 0
            | RoundRobin -> 1
            | Pinned -> 2
          
          let from_int = function
            | 0 -> Ok DispatchToSingle
            | 1 -> Ok RoundRobin
            | 2 -> Ok Pinned
            | n -> Error (`Unknown_enum_value n)
          
        end
        and Options : sig
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream of CreateReq.StreamOptions.t | `All of CreateReq.AllOptions.t ]; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; group_name: string; settings: CreateReq.Settings.t option } 
          val make : ?stream_option:[ `not_set | `Stream of CreateReq.StreamOptions.t | `All of CreateReq.AllOptions.t ] -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?group_name:string -> ?settings:CreateReq.Settings.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.CreateReq.Options"
          type t = { stream_option: [ `not_set | `Stream of CreateReq.StreamOptions.t | `All of CreateReq.AllOptions.t ]; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; group_name: string; settings: CreateReq.Settings.t option }
          let make =
            fun ?stream_option ?stream_identifier ?group_name ?settings () -> 
            let stream_option = match stream_option with Some v -> v | None -> `not_set in
            let group_name = match group_name with Some v -> v | None -> {||} in
            { stream_option; stream_identifier; group_name; settings }
          
          let to_proto =
            let apply = fun ~f:f' { stream_option; stream_identifier; group_name; settings } -> f' [] stream_option stream_identifier group_name settings in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream v -> oneof_elem (4, (message (fun t -> CreateReq.StreamOptions.to_proto t)), v) | `All v -> oneof_elem (5, (message (fun t -> CreateReq.AllOptions.to_proto t)), v))) ^:: basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> CreateReq.Settings.to_proto t))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_option stream_identifier group_name settings -> { stream_option; stream_identifier; group_name; settings } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (4, (message (fun t -> CreateReq.StreamOptions.from_proto t)), fun v -> `Stream v); oneof_elem (5, (message (fun t -> CreateReq.AllOptions.from_proto t)), fun v -> `All v) ]) ^:: basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> CreateReq.Settings.from_proto t))) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and StreamOptions : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?revision_option:[ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.CreateReq.StreamOptions"
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?stream_identifier ?revision_option () -> 
            let revision_option = match revision_option with Some v -> v | None -> `not_set in
            { stream_identifier; revision_option }
          
          let to_proto =
            let apply = fun ~f:f' { stream_identifier; revision_option } -> f' [] stream_identifier revision_option in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Revision v -> oneof_elem (2, uint64_int, v) | `Start v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `End v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_identifier revision_option -> { stream_identifier; revision_option } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: oneof ([ oneof_elem (2, uint64_int, fun v -> `Revision v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Start v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `End v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and AllOptions : sig
          module rec FilterOptions : sig
            module rec Expression : sig
              val name': unit -> string
              type t = { regex: string; prefix: string list } 
              val make : ?regex:string -> ?prefix:string list -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { filter: [ `not_set | `Stream_identifier of CreateReq.AllOptions.FilterOptions.Expression.t | `Event_type of CreateReq.AllOptions.FilterOptions.Expression.t ]; window: [ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ]; checkpointIntervalMultiplier: int } 
            val make : ?filter:[ `not_set | `Stream_identifier of CreateReq.AllOptions.FilterOptions.Expression.t | `Event_type of CreateReq.AllOptions.FilterOptions.Expression.t ] -> ?window:[ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?checkpointIntervalMultiplier:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { all_option: [ `not_set | `Position of CreateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ]; filter_option: [ `not_set | `Filter of CreateReq.AllOptions.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?all_option:[ `not_set | `Position of CreateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?filter_option:[ `not_set | `Filter of CreateReq.AllOptions.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec FilterOptions : sig
            module rec Expression : sig
              val name': unit -> string
              type t = { regex: string; prefix: string list } 
              val make : ?regex:string -> ?prefix:string list -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { filter: [ `not_set | `Stream_identifier of CreateReq.AllOptions.FilterOptions.Expression.t | `Event_type of CreateReq.AllOptions.FilterOptions.Expression.t ]; window: [ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ]; checkpointIntervalMultiplier: int } 
            val make : ?filter:[ `not_set | `Stream_identifier of CreateReq.AllOptions.FilterOptions.Expression.t | `Event_type of CreateReq.AllOptions.FilterOptions.Expression.t ] -> ?window:[ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?checkpointIntervalMultiplier:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            module rec Expression : sig
              val name': unit -> string
              type t = { regex: string; prefix: string list } 
              val make : ?regex:string -> ?prefix:string list -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end = struct 
              let name' () = "persistent.event_store.client.persistent_subscriptions.CreateReq.AllOptions.FilterOptions.Expression"
              type t = { regex: string; prefix: string list }
              let make =
                fun ?regex ?prefix () -> 
                let regex = match regex with Some v -> v | None -> {||} in
                let prefix = match prefix with Some v -> v | None -> [] in
                { regex; prefix }
              
              let to_proto =
                let apply = fun ~f:f' { regex; prefix } -> f' [] regex prefix in
                let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, string, packed) ^:: nil ) in
                let serialize = Runtime'.Serialize.serialize [] (spec) in
                fun t -> apply ~f:serialize t
              
              let from_proto =
                let constructor = fun _extensions regex prefix -> { regex; prefix } in
                let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, string, packed) ^:: nil ) in
                let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
                fun writer -> deserialize writer |> Runtime'.Result.open_error
              
            end
            let name' () = "persistent.event_store.client.persistent_subscriptions.CreateReq.AllOptions.FilterOptions"
            type t = { filter: [ `not_set | `Stream_identifier of CreateReq.AllOptions.FilterOptions.Expression.t | `Event_type of CreateReq.AllOptions.FilterOptions.Expression.t ]; window: [ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ]; checkpointIntervalMultiplier: int }
            let make =
              fun ?filter ?window ?checkpointIntervalMultiplier () -> 
              let filter = match filter with Some v -> v | None -> `not_set in
              let window = match window with Some v -> v | None -> `not_set in
              let checkpointIntervalMultiplier = match checkpointIntervalMultiplier with Some v -> v | None -> 0 in
              { filter; window; checkpointIntervalMultiplier }
            
            let to_proto =
              let apply = fun ~f:f' { filter; window; checkpointIntervalMultiplier } -> f' [] filter window checkpointIntervalMultiplier in
              let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream_identifier v -> oneof_elem (1, (message (fun t -> CreateReq.AllOptions.FilterOptions.Expression.to_proto t)), v) | `Event_type v -> oneof_elem (2, (message (fun t -> CreateReq.AllOptions.FilterOptions.Expression.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Max v -> oneof_elem (3, uint32_int, v) | `Count v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: basic (5, uint32_int, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions filter window checkpointIntervalMultiplier -> { filter; window; checkpointIntervalMultiplier } in
              let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> CreateReq.AllOptions.FilterOptions.Expression.from_proto t)), fun v -> `Stream_identifier v); oneof_elem (2, (message (fun t -> CreateReq.AllOptions.FilterOptions.Expression.from_proto t)), fun v -> `Event_type v) ]) ^:: oneof ([ oneof_elem (3, uint32_int, fun v -> `Max v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Count v) ]) ^:: basic (5, uint32_int, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          let name' () = "persistent.event_store.client.persistent_subscriptions.CreateReq.AllOptions"
          type t = { all_option: [ `not_set | `Position of CreateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ]; filter_option: [ `not_set | `Filter of CreateReq.AllOptions.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?all_option ?filter_option () -> 
            let all_option = match all_option with Some v -> v | None -> `not_set in
            let filter_option = match filter_option with Some v -> v | None -> `not_set in
            { all_option; filter_option }
          
          let to_proto =
            let apply = fun ~f:f' { all_option; filter_option } -> f' [] all_option filter_option in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Position v -> oneof_elem (1, (message (fun t -> CreateReq.Position.to_proto t)), v) | `Start v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `End v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Filter v -> oneof_elem (4, (message (fun t -> CreateReq.AllOptions.FilterOptions.to_proto t)), v) | `No_filter v -> oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions all_option filter_option -> { all_option; filter_option } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> CreateReq.Position.from_proto t)), fun v -> `Position v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Start v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `End v) ]) ^:: oneof ([ oneof_elem (4, (message (fun t -> CreateReq.AllOptions.FilterOptions.from_proto t)), fun v -> `Filter v); oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_filter v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.CreateReq.Position"
          type t = { commit_position: int; prepare_position: int }
          let make =
            fun ?commit_position ?prepare_position () -> 
            let commit_position = match commit_position with Some v -> v | None -> 0 in
            let prepare_position = match prepare_position with Some v -> v | None -> 0 in
            { commit_position; prepare_position }
          
          let to_proto =
            let apply = fun ~f:f' { commit_position; prepare_position } -> f' [] commit_position prepare_position in
            let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions commit_position prepare_position -> { commit_position; prepare_position } in
            let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and Settings : sig
          val name': unit -> string
          type t = { resolve_links: bool; revision: int; extra_statistics: bool; max_retry_count: int; min_checkpoint_count: int; max_checkpoint_count: int; max_subscriber_count: int; live_buffer_size: int; read_batch_size: int; history_buffer_size: int; named_consumer_strategy: CreateReq.ConsumerStrategy.t; message_timeout: [ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ]; checkpoint_after: [ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ]; consumer_strategy: string } 
          val make : ?resolve_links:bool -> ?revision:int -> ?extra_statistics:bool -> ?max_retry_count:int -> ?min_checkpoint_count:int -> ?max_checkpoint_count:int -> ?max_subscriber_count:int -> ?live_buffer_size:int -> ?read_batch_size:int -> ?history_buffer_size:int -> ?named_consumer_strategy:CreateReq.ConsumerStrategy.t -> ?message_timeout:[ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ] -> ?checkpoint_after:[ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ] -> ?consumer_strategy:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.CreateReq.Settings"
          type t = { resolve_links: bool; revision: int; extra_statistics: bool; max_retry_count: int; min_checkpoint_count: int; max_checkpoint_count: int; max_subscriber_count: int; live_buffer_size: int; read_batch_size: int; history_buffer_size: int; named_consumer_strategy: CreateReq.ConsumerStrategy.t; message_timeout: [ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ]; checkpoint_after: [ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ]; consumer_strategy: string }
          let make =
            fun ?resolve_links ?revision ?extra_statistics ?max_retry_count ?min_checkpoint_count ?max_checkpoint_count ?max_subscriber_count ?live_buffer_size ?read_batch_size ?history_buffer_size ?named_consumer_strategy ?message_timeout ?checkpoint_after ?consumer_strategy () -> 
            let resolve_links = match resolve_links with Some v -> v | None -> false in
            let revision = match revision with Some v -> v | None -> 0 in
            let extra_statistics = match extra_statistics with Some v -> v | None -> false in
            let max_retry_count = match max_retry_count with Some v -> v | None -> 0 in
            let min_checkpoint_count = match min_checkpoint_count with Some v -> v | None -> 0 in
            let max_checkpoint_count = match max_checkpoint_count with Some v -> v | None -> 0 in
            let max_subscriber_count = match max_subscriber_count with Some v -> v | None -> 0 in
            let live_buffer_size = match live_buffer_size with Some v -> v | None -> 0 in
            let read_batch_size = match read_batch_size with Some v -> v | None -> 0 in
            let history_buffer_size = match history_buffer_size with Some v -> v | None -> 0 in
            let named_consumer_strategy = match named_consumer_strategy with Some v -> v | None -> (CreateReq.ConsumerStrategy.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
            let message_timeout = match message_timeout with Some v -> v | None -> `not_set in
            let checkpoint_after = match checkpoint_after with Some v -> v | None -> `not_set in
            let consumer_strategy = match consumer_strategy with Some v -> v | None -> {||} in
            { resolve_links; revision; extra_statistics; max_retry_count; min_checkpoint_count; max_checkpoint_count; max_subscriber_count; live_buffer_size; read_batch_size; history_buffer_size; named_consumer_strategy; message_timeout; checkpoint_after; consumer_strategy }
          
          let to_proto =
            let apply = fun ~f:f' { resolve_links; revision; extra_statistics; max_retry_count; min_checkpoint_count; max_checkpoint_count; max_subscriber_count; live_buffer_size; read_batch_size; history_buffer_size; named_consumer_strategy; message_timeout; checkpoint_after; consumer_strategy } -> f' [] resolve_links revision extra_statistics max_retry_count min_checkpoint_count max_checkpoint_count max_subscriber_count live_buffer_size read_batch_size history_buffer_size named_consumer_strategy message_timeout checkpoint_after consumer_strategy in
            let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: basic (10, int32_int, proto3) ^:: basic (11, int32_int, proto3) ^:: basic (12, int32_int, proto3) ^:: basic (13, (enum CreateReq.ConsumerStrategy.to_int), proto3) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Message_timeout_ticks v -> oneof_elem (4, int64_int, v) | `Message_timeout_ms v -> oneof_elem (14, int32_int, v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Checkpoint_after_ticks v -> oneof_elem (6, int64_int, v) | `Checkpoint_after_ms v -> oneof_elem (15, int32_int, v))) ^:: basic (16, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions resolve_links revision extra_statistics max_retry_count min_checkpoint_count max_checkpoint_count max_subscriber_count live_buffer_size read_batch_size history_buffer_size named_consumer_strategy message_timeout checkpoint_after consumer_strategy -> { resolve_links; revision; extra_statistics; max_retry_count; min_checkpoint_count; max_checkpoint_count; max_subscriber_count; live_buffer_size; read_batch_size; history_buffer_size; named_consumer_strategy; message_timeout; checkpoint_after; consumer_strategy } in
            let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: basic (10, int32_int, proto3) ^:: basic (11, int32_int, proto3) ^:: basic (12, int32_int, proto3) ^:: basic (13, (enum CreateReq.ConsumerStrategy.from_int), proto3) ^:: oneof ([ oneof_elem (4, int64_int, fun v -> `Message_timeout_ticks v); oneof_elem (14, int32_int, fun v -> `Message_timeout_ms v) ]) ^:: oneof ([ oneof_elem (6, int64_int, fun v -> `Checkpoint_after_ticks v); oneof_elem (15, int32_int, fun v -> `Checkpoint_after_ms v) ]) ^:: basic (16, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "persistent.event_store.client.persistent_subscriptions.CreateReq"
        type t = CreateReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> CreateReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> CreateReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and CreateResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "persistent.event_store.client.persistent_subscriptions.CreateResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and UpdateReq : sig
        module rec ConsumerStrategy : sig
          type t = DispatchToSingle | RoundRobin | Pinned 
          val to_int: t -> int
          val from_int: int -> (t, [> Runtime'.Result.error]) result
        end
        and Options : sig
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream of UpdateReq.StreamOptions.t | `All of UpdateReq.AllOptions.t ]; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; group_name: string; settings: UpdateReq.Settings.t option } 
          val make : ?stream_option:[ `not_set | `Stream of UpdateReq.StreamOptions.t | `All of UpdateReq.AllOptions.t ] -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?group_name:string -> ?settings:UpdateReq.Settings.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and StreamOptions : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?revision_option:[ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and AllOptions : sig
          val name': unit -> string
          type t = [ `not_set | `Position of UpdateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] 
          val make : ?all_option:[ `not_set | `Position of UpdateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and Settings : sig
          val name': unit -> string
          type t = { resolve_links: bool; revision: int; extra_statistics: bool; max_retry_count: int; min_checkpoint_count: int; max_checkpoint_count: int; max_subscriber_count: int; live_buffer_size: int; read_batch_size: int; history_buffer_size: int; named_consumer_strategy: UpdateReq.ConsumerStrategy.t; message_timeout: [ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ]; checkpoint_after: [ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ] } 
          val make : ?resolve_links:bool -> ?revision:int -> ?extra_statistics:bool -> ?max_retry_count:int -> ?min_checkpoint_count:int -> ?max_checkpoint_count:int -> ?max_subscriber_count:int -> ?live_buffer_size:int -> ?read_batch_size:int -> ?history_buffer_size:int -> ?named_consumer_strategy:UpdateReq.ConsumerStrategy.t -> ?message_timeout:[ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ] -> ?checkpoint_after:[ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = UpdateReq.Options.t option 
        val make : ?options:UpdateReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec ConsumerStrategy : sig
          type t = DispatchToSingle | RoundRobin | Pinned 
          val to_int: t -> int
          val from_int: int -> (t, [> Runtime'.Result.error]) result
        end = struct 
          type t = DispatchToSingle | RoundRobin | Pinned 
          let to_int = function
            | DispatchToSingle -> 0
            | RoundRobin -> 1
            | Pinned -> 2
          
          let from_int = function
            | 0 -> Ok DispatchToSingle
            | 1 -> Ok RoundRobin
            | 2 -> Ok Pinned
            | n -> Error (`Unknown_enum_value n)
          
        end
        and Options : sig
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream of UpdateReq.StreamOptions.t | `All of UpdateReq.AllOptions.t ]; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; group_name: string; settings: UpdateReq.Settings.t option } 
          val make : ?stream_option:[ `not_set | `Stream of UpdateReq.StreamOptions.t | `All of UpdateReq.AllOptions.t ] -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?group_name:string -> ?settings:UpdateReq.Settings.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.UpdateReq.Options"
          type t = { stream_option: [ `not_set | `Stream of UpdateReq.StreamOptions.t | `All of UpdateReq.AllOptions.t ]; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; group_name: string; settings: UpdateReq.Settings.t option }
          let make =
            fun ?stream_option ?stream_identifier ?group_name ?settings () -> 
            let stream_option = match stream_option with Some v -> v | None -> `not_set in
            let group_name = match group_name with Some v -> v | None -> {||} in
            { stream_option; stream_identifier; group_name; settings }
          
          let to_proto =
            let apply = fun ~f:f' { stream_option; stream_identifier; group_name; settings } -> f' [] stream_option stream_identifier group_name settings in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream v -> oneof_elem (4, (message (fun t -> UpdateReq.StreamOptions.to_proto t)), v) | `All v -> oneof_elem (5, (message (fun t -> UpdateReq.AllOptions.to_proto t)), v))) ^:: basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> UpdateReq.Settings.to_proto t))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_option stream_identifier group_name settings -> { stream_option; stream_identifier; group_name; settings } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (4, (message (fun t -> UpdateReq.StreamOptions.from_proto t)), fun v -> `Stream v); oneof_elem (5, (message (fun t -> UpdateReq.AllOptions.from_proto t)), fun v -> `All v) ]) ^:: basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> UpdateReq.Settings.from_proto t))) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and StreamOptions : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?revision_option:[ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.UpdateReq.StreamOptions"
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?stream_identifier ?revision_option () -> 
            let revision_option = match revision_option with Some v -> v | None -> `not_set in
            { stream_identifier; revision_option }
          
          let to_proto =
            let apply = fun ~f:f' { stream_identifier; revision_option } -> f' [] stream_identifier revision_option in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Revision v -> oneof_elem (2, uint64_int, v) | `Start v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `End v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_identifier revision_option -> { stream_identifier; revision_option } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: oneof ([ oneof_elem (2, uint64_int, fun v -> `Revision v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Start v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `End v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and AllOptions : sig
          val name': unit -> string
          type t = [ `not_set | `Position of UpdateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] 
          val make : ?all_option:[ `not_set | `Position of UpdateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.UpdateReq.AllOptions"
          type t = [ `not_set | `Position of UpdateReq.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ]
          let make =
            fun ?all_option () -> 
            let all_option = match all_option with Some v -> v | None -> `not_set in
            all_option
          
          let to_proto =
            let apply = fun ~f:f' all_option -> f' [] all_option in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Position v -> oneof_elem (1, (message (fun t -> UpdateReq.Position.to_proto t)), v) | `Start v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `End v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions all_option -> all_option in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> UpdateReq.Position.from_proto t)), fun v -> `Position v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Start v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `End v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.UpdateReq.Position"
          type t = { commit_position: int; prepare_position: int }
          let make =
            fun ?commit_position ?prepare_position () -> 
            let commit_position = match commit_position with Some v -> v | None -> 0 in
            let prepare_position = match prepare_position with Some v -> v | None -> 0 in
            { commit_position; prepare_position }
          
          let to_proto =
            let apply = fun ~f:f' { commit_position; prepare_position } -> f' [] commit_position prepare_position in
            let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions commit_position prepare_position -> { commit_position; prepare_position } in
            let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and Settings : sig
          val name': unit -> string
          type t = { resolve_links: bool; revision: int; extra_statistics: bool; max_retry_count: int; min_checkpoint_count: int; max_checkpoint_count: int; max_subscriber_count: int; live_buffer_size: int; read_batch_size: int; history_buffer_size: int; named_consumer_strategy: UpdateReq.ConsumerStrategy.t; message_timeout: [ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ]; checkpoint_after: [ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ] } 
          val make : ?resolve_links:bool -> ?revision:int -> ?extra_statistics:bool -> ?max_retry_count:int -> ?min_checkpoint_count:int -> ?max_checkpoint_count:int -> ?max_subscriber_count:int -> ?live_buffer_size:int -> ?read_batch_size:int -> ?history_buffer_size:int -> ?named_consumer_strategy:UpdateReq.ConsumerStrategy.t -> ?message_timeout:[ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ] -> ?checkpoint_after:[ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.UpdateReq.Settings"
          type t = { resolve_links: bool; revision: int; extra_statistics: bool; max_retry_count: int; min_checkpoint_count: int; max_checkpoint_count: int; max_subscriber_count: int; live_buffer_size: int; read_batch_size: int; history_buffer_size: int; named_consumer_strategy: UpdateReq.ConsumerStrategy.t; message_timeout: [ `not_set | `Message_timeout_ticks of int | `Message_timeout_ms of int ]; checkpoint_after: [ `not_set | `Checkpoint_after_ticks of int | `Checkpoint_after_ms of int ] }
          let make =
            fun ?resolve_links ?revision ?extra_statistics ?max_retry_count ?min_checkpoint_count ?max_checkpoint_count ?max_subscriber_count ?live_buffer_size ?read_batch_size ?history_buffer_size ?named_consumer_strategy ?message_timeout ?checkpoint_after () -> 
            let resolve_links = match resolve_links with Some v -> v | None -> false in
            let revision = match revision with Some v -> v | None -> 0 in
            let extra_statistics = match extra_statistics with Some v -> v | None -> false in
            let max_retry_count = match max_retry_count with Some v -> v | None -> 0 in
            let min_checkpoint_count = match min_checkpoint_count with Some v -> v | None -> 0 in
            let max_checkpoint_count = match max_checkpoint_count with Some v -> v | None -> 0 in
            let max_subscriber_count = match max_subscriber_count with Some v -> v | None -> 0 in
            let live_buffer_size = match live_buffer_size with Some v -> v | None -> 0 in
            let read_batch_size = match read_batch_size with Some v -> v | None -> 0 in
            let history_buffer_size = match history_buffer_size with Some v -> v | None -> 0 in
            let named_consumer_strategy = match named_consumer_strategy with Some v -> v | None -> (UpdateReq.ConsumerStrategy.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
            let message_timeout = match message_timeout with Some v -> v | None -> `not_set in
            let checkpoint_after = match checkpoint_after with Some v -> v | None -> `not_set in
            { resolve_links; revision; extra_statistics; max_retry_count; min_checkpoint_count; max_checkpoint_count; max_subscriber_count; live_buffer_size; read_batch_size; history_buffer_size; named_consumer_strategy; message_timeout; checkpoint_after }
          
          let to_proto =
            let apply = fun ~f:f' { resolve_links; revision; extra_statistics; max_retry_count; min_checkpoint_count; max_checkpoint_count; max_subscriber_count; live_buffer_size; read_batch_size; history_buffer_size; named_consumer_strategy; message_timeout; checkpoint_after } -> f' [] resolve_links revision extra_statistics max_retry_count min_checkpoint_count max_checkpoint_count max_subscriber_count live_buffer_size read_batch_size history_buffer_size named_consumer_strategy message_timeout checkpoint_after in
            let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: basic (10, int32_int, proto3) ^:: basic (11, int32_int, proto3) ^:: basic (12, int32_int, proto3) ^:: basic (13, (enum UpdateReq.ConsumerStrategy.to_int), proto3) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Message_timeout_ticks v -> oneof_elem (4, int64_int, v) | `Message_timeout_ms v -> oneof_elem (14, int32_int, v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Checkpoint_after_ticks v -> oneof_elem (6, int64_int, v) | `Checkpoint_after_ms v -> oneof_elem (15, int32_int, v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions resolve_links revision extra_statistics max_retry_count min_checkpoint_count max_checkpoint_count max_subscriber_count live_buffer_size read_batch_size history_buffer_size named_consumer_strategy message_timeout checkpoint_after -> { resolve_links; revision; extra_statistics; max_retry_count; min_checkpoint_count; max_checkpoint_count; max_subscriber_count; live_buffer_size; read_batch_size; history_buffer_size; named_consumer_strategy; message_timeout; checkpoint_after } in
            let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: basic (10, int32_int, proto3) ^:: basic (11, int32_int, proto3) ^:: basic (12, int32_int, proto3) ^:: basic (13, (enum UpdateReq.ConsumerStrategy.from_int), proto3) ^:: oneof ([ oneof_elem (4, int64_int, fun v -> `Message_timeout_ticks v); oneof_elem (14, int32_int, fun v -> `Message_timeout_ms v) ]) ^:: oneof ([ oneof_elem (6, int64_int, fun v -> `Checkpoint_after_ticks v); oneof_elem (15, int32_int, fun v -> `Checkpoint_after_ms v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "persistent.event_store.client.persistent_subscriptions.UpdateReq"
        type t = UpdateReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> UpdateReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> UpdateReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and UpdateResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "persistent.event_store.client.persistent_subscriptions.UpdateResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DeleteReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; group_name: string } 
          val make : ?stream_option:[ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?group_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = DeleteReq.Options.t option 
        val make : ?options:DeleteReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; group_name: string } 
          val make : ?stream_option:[ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?group_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.DeleteReq.Options"
          type t = { stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; group_name: string }
          let make =
            fun ?stream_option ?group_name () -> 
            let stream_option = match stream_option with Some v -> v | None -> `not_set in
            let group_name = match group_name with Some v -> v | None -> {||} in
            { stream_option; group_name }
          
          let to_proto =
            let apply = fun ~f:f' { stream_option; group_name } -> f' [] stream_option group_name in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream_identifier v -> oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t)), v) | `All v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: basic (2, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_option group_name -> { stream_option; group_name } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t)), fun v -> `Stream_identifier v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `All v) ]) ^:: basic (2, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "persistent.event_store.client.persistent_subscriptions.DeleteReq"
        type t = DeleteReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> DeleteReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> DeleteReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DeleteResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "persistent.event_store.client.persistent_subscriptions.DeleteResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and GetInfoReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; group_name: string } 
          val make : ?stream_option:[ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?group_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = GetInfoReq.Options.t option 
        val make : ?options:GetInfoReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; group_name: string } 
          val make : ?stream_option:[ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?group_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.GetInfoReq.Options"
          type t = { stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; group_name: string }
          let make =
            fun ?stream_option ?group_name () -> 
            let stream_option = match stream_option with Some v -> v | None -> `not_set in
            let group_name = match group_name with Some v -> v | None -> {||} in
            { stream_option; group_name }
          
          let to_proto =
            let apply = fun ~f:f' { stream_option; group_name } -> f' [] stream_option group_name in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream_identifier v -> oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t)), v) | `All v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: basic (3, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_option group_name -> { stream_option; group_name } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t)), fun v -> `Stream_identifier v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `All v) ]) ^:: basic (3, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "persistent.event_store.client.persistent_subscriptions.GetInfoReq"
        type t = GetInfoReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> GetInfoReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> GetInfoReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and GetInfoResp : sig
        val name': unit -> string
        type t = SubscriptionInfo.t option 
        val make : ?subscription_info:SubscriptionInfo.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "persistent.event_store.client.persistent_subscriptions.GetInfoResp"
        type t = SubscriptionInfo.t option
        let make =
          fun ?subscription_info () -> 
          
          subscription_info
        
        let to_proto =
          let apply = fun ~f:f' subscription_info -> f' [] subscription_info in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> SubscriptionInfo.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions subscription_info -> subscription_info in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> SubscriptionInfo.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and SubscriptionInfo : sig
        module rec ConnectionInfo : sig
          val name': unit -> string
          type t = { from: string; username: string; average_items_per_second: int; total_items: int; count_since_last_measurement: int; observed_measurements: SubscriptionInfo.Measurement.t list; available_slots: int; in_flight_messages: int; connection_name: string } 
          val make : ?from:string -> ?username:string -> ?average_items_per_second:int -> ?total_items:int -> ?count_since_last_measurement:int -> ?observed_measurements:SubscriptionInfo.Measurement.t list -> ?available_slots:int -> ?in_flight_messages:int -> ?connection_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and Measurement : sig
          val name': unit -> string
          type t = { key: string; value: int } 
          val make : ?key:string -> ?value:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = { event_source: string; group_name: string; status: string; connections: SubscriptionInfo.ConnectionInfo.t list; average_per_second: int; total_items: int; count_since_last_measurement: int; last_checkpointed_event_position: string; last_known_event_position: string; resolve_link_tos: bool; start_from: string; message_timeout_milliseconds: int; extra_statistics: bool; max_retry_count: int; live_buffer_size: int; buffer_size: int; read_batch_size: int; check_point_after_milliseconds: int; min_check_point_count: int; max_check_point_count: int; read_buffer_count: int; live_buffer_count: int; retry_buffer_count: int; total_in_flight_messages: int; outstanding_messages_count: int; named_consumer_strategy: string; max_subscriber_count: int; parked_message_count: int } 
        val make : ?event_source:string -> ?group_name:string -> ?status:string -> ?connections:SubscriptionInfo.ConnectionInfo.t list -> ?average_per_second:int -> ?total_items:int -> ?count_since_last_measurement:int -> ?last_checkpointed_event_position:string -> ?last_known_event_position:string -> ?resolve_link_tos:bool -> ?start_from:string -> ?message_timeout_milliseconds:int -> ?extra_statistics:bool -> ?max_retry_count:int -> ?live_buffer_size:int -> ?buffer_size:int -> ?read_batch_size:int -> ?check_point_after_milliseconds:int -> ?min_check_point_count:int -> ?max_check_point_count:int -> ?read_buffer_count:int -> ?live_buffer_count:int -> ?retry_buffer_count:int -> ?total_in_flight_messages:int -> ?outstanding_messages_count:int -> ?named_consumer_strategy:string -> ?max_subscriber_count:int -> ?parked_message_count:int -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec ConnectionInfo : sig
          val name': unit -> string
          type t = { from: string; username: string; average_items_per_second: int; total_items: int; count_since_last_measurement: int; observed_measurements: SubscriptionInfo.Measurement.t list; available_slots: int; in_flight_messages: int; connection_name: string } 
          val make : ?from:string -> ?username:string -> ?average_items_per_second:int -> ?total_items:int -> ?count_since_last_measurement:int -> ?observed_measurements:SubscriptionInfo.Measurement.t list -> ?available_slots:int -> ?in_flight_messages:int -> ?connection_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.SubscriptionInfo.ConnectionInfo"
          type t = { from: string; username: string; average_items_per_second: int; total_items: int; count_since_last_measurement: int; observed_measurements: SubscriptionInfo.Measurement.t list; available_slots: int; in_flight_messages: int; connection_name: string }
          let make =
            fun ?from ?username ?average_items_per_second ?total_items ?count_since_last_measurement ?observed_measurements ?available_slots ?in_flight_messages ?connection_name () -> 
            let from = match from with Some v -> v | None -> {||} in
            let username = match username with Some v -> v | None -> {||} in
            let average_items_per_second = match average_items_per_second with Some v -> v | None -> 0 in
            let total_items = match total_items with Some v -> v | None -> 0 in
            let count_since_last_measurement = match count_since_last_measurement with Some v -> v | None -> 0 in
            let observed_measurements = match observed_measurements with Some v -> v | None -> [] in
            let available_slots = match available_slots with Some v -> v | None -> 0 in
            let in_flight_messages = match in_flight_messages with Some v -> v | None -> 0 in
            let connection_name = match connection_name with Some v -> v | None -> {||} in
            { from; username; average_items_per_second; total_items; count_since_last_measurement; observed_measurements; available_slots; in_flight_messages; connection_name }
          
          let to_proto =
            let apply = fun ~f:f' { from; username; average_items_per_second; total_items; count_since_last_measurement; observed_measurements; available_slots; in_flight_messages; connection_name } -> f' [] from username average_items_per_second total_items count_since_last_measurement observed_measurements available_slots in_flight_messages connection_name in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, int64_int, proto3) ^:: basic (5, int64_int, proto3) ^:: repeated (6, (message (fun t -> SubscriptionInfo.Measurement.to_proto t)), not_packed) ^:: basic (7, int32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions from username average_items_per_second total_items count_since_last_measurement observed_measurements available_slots in_flight_messages connection_name -> { from; username; average_items_per_second; total_items; count_since_last_measurement; observed_measurements; available_slots; in_flight_messages; connection_name } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, int64_int, proto3) ^:: basic (5, int64_int, proto3) ^:: repeated (6, (message (fun t -> SubscriptionInfo.Measurement.from_proto t)), not_packed) ^:: basic (7, int32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and Measurement : sig
          val name': unit -> string
          type t = { key: string; value: int } 
          val make : ?key:string -> ?value:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.SubscriptionInfo.Measurement"
          type t = { key: string; value: int }
          let make =
            fun ?key ?value () -> 
            let key = match key with Some v -> v | None -> {||} in
            let value = match value with Some v -> v | None -> 0 in
            { key; value }
          
          let to_proto =
            let apply = fun ~f:f' { key; value } -> f' [] key value in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, int64_int, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions key value -> { key; value } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, int64_int, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "persistent.event_store.client.persistent_subscriptions.SubscriptionInfo"
        type t = { event_source: string; group_name: string; status: string; connections: SubscriptionInfo.ConnectionInfo.t list; average_per_second: int; total_items: int; count_since_last_measurement: int; last_checkpointed_event_position: string; last_known_event_position: string; resolve_link_tos: bool; start_from: string; message_timeout_milliseconds: int; extra_statistics: bool; max_retry_count: int; live_buffer_size: int; buffer_size: int; read_batch_size: int; check_point_after_milliseconds: int; min_check_point_count: int; max_check_point_count: int; read_buffer_count: int; live_buffer_count: int; retry_buffer_count: int; total_in_flight_messages: int; outstanding_messages_count: int; named_consumer_strategy: string; max_subscriber_count: int; parked_message_count: int }
        let make =
          fun ?event_source ?group_name ?status ?connections ?average_per_second ?total_items ?count_since_last_measurement ?last_checkpointed_event_position ?last_known_event_position ?resolve_link_tos ?start_from ?message_timeout_milliseconds ?extra_statistics ?max_retry_count ?live_buffer_size ?buffer_size ?read_batch_size ?check_point_after_milliseconds ?min_check_point_count ?max_check_point_count ?read_buffer_count ?live_buffer_count ?retry_buffer_count ?total_in_flight_messages ?outstanding_messages_count ?named_consumer_strategy ?max_subscriber_count ?parked_message_count () -> 
          let event_source = match event_source with Some v -> v | None -> {||} in
          let group_name = match group_name with Some v -> v | None -> {||} in
          let status = match status with Some v -> v | None -> {||} in
          let connections = match connections with Some v -> v | None -> [] in
          let average_per_second = match average_per_second with Some v -> v | None -> 0 in
          let total_items = match total_items with Some v -> v | None -> 0 in
          let count_since_last_measurement = match count_since_last_measurement with Some v -> v | None -> 0 in
          let last_checkpointed_event_position = match last_checkpointed_event_position with Some v -> v | None -> {||} in
          let last_known_event_position = match last_known_event_position with Some v -> v | None -> {||} in
          let resolve_link_tos = match resolve_link_tos with Some v -> v | None -> false in
          let start_from = match start_from with Some v -> v | None -> {||} in
          let message_timeout_milliseconds = match message_timeout_milliseconds with Some v -> v | None -> 0 in
          let extra_statistics = match extra_statistics with Some v -> v | None -> false in
          let max_retry_count = match max_retry_count with Some v -> v | None -> 0 in
          let live_buffer_size = match live_buffer_size with Some v -> v | None -> 0 in
          let buffer_size = match buffer_size with Some v -> v | None -> 0 in
          let read_batch_size = match read_batch_size with Some v -> v | None -> 0 in
          let check_point_after_milliseconds = match check_point_after_milliseconds with Some v -> v | None -> 0 in
          let min_check_point_count = match min_check_point_count with Some v -> v | None -> 0 in
          let max_check_point_count = match max_check_point_count with Some v -> v | None -> 0 in
          let read_buffer_count = match read_buffer_count with Some v -> v | None -> 0 in
          let live_buffer_count = match live_buffer_count with Some v -> v | None -> 0 in
          let retry_buffer_count = match retry_buffer_count with Some v -> v | None -> 0 in
          let total_in_flight_messages = match total_in_flight_messages with Some v -> v | None -> 0 in
          let outstanding_messages_count = match outstanding_messages_count with Some v -> v | None -> 0 in
          let named_consumer_strategy = match named_consumer_strategy with Some v -> v | None -> {||} in
          let max_subscriber_count = match max_subscriber_count with Some v -> v | None -> 0 in
          let parked_message_count = match parked_message_count with Some v -> v | None -> 0 in
          { event_source; group_name; status; connections; average_per_second; total_items; count_since_last_measurement; last_checkpointed_event_position; last_known_event_position; resolve_link_tos; start_from; message_timeout_milliseconds; extra_statistics; max_retry_count; live_buffer_size; buffer_size; read_batch_size; check_point_after_milliseconds; min_check_point_count; max_check_point_count; read_buffer_count; live_buffer_count; retry_buffer_count; total_in_flight_messages; outstanding_messages_count; named_consumer_strategy; max_subscriber_count; parked_message_count }
        
        let to_proto =
          let apply = fun ~f:f' { event_source; group_name; status; connections; average_per_second; total_items; count_since_last_measurement; last_checkpointed_event_position; last_known_event_position; resolve_link_tos; start_from; message_timeout_milliseconds; extra_statistics; max_retry_count; live_buffer_size; buffer_size; read_batch_size; check_point_after_milliseconds; min_check_point_count; max_check_point_count; read_buffer_count; live_buffer_count; retry_buffer_count; total_in_flight_messages; outstanding_messages_count; named_consumer_strategy; max_subscriber_count; parked_message_count } -> f' [] event_source group_name status connections average_per_second total_items count_since_last_measurement last_checkpointed_event_position last_known_event_position resolve_link_tos start_from message_timeout_milliseconds extra_statistics max_retry_count live_buffer_size buffer_size read_batch_size check_point_after_milliseconds min_check_point_count max_check_point_count read_buffer_count live_buffer_count retry_buffer_count total_in_flight_messages outstanding_messages_count named_consumer_strategy max_subscriber_count parked_message_count in
          let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> SubscriptionInfo.ConnectionInfo.to_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: basic (6, int64_int, proto3) ^:: basic (7, int64_int, proto3) ^:: basic (8, string, proto3) ^:: basic (9, string, proto3) ^:: basic (10, bool, proto3) ^:: basic (11, string, proto3) ^:: basic (12, int32_int, proto3) ^:: basic (13, bool, proto3) ^:: basic (14, int32_int, proto3) ^:: basic (15, int32_int, proto3) ^:: basic (16, int32_int, proto3) ^:: basic (17, int32_int, proto3) ^:: basic (18, int32_int, proto3) ^:: basic (19, int32_int, proto3) ^:: basic (20, int32_int, proto3) ^:: basic (21, int32_int, proto3) ^:: basic (22, int64_int, proto3) ^:: basic (23, int32_int, proto3) ^:: basic (24, int32_int, proto3) ^:: basic (25, int32_int, proto3) ^:: basic (26, string, proto3) ^:: basic (27, int32_int, proto3) ^:: basic (28, int64_int, proto3) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions event_source group_name status connections average_per_second total_items count_since_last_measurement last_checkpointed_event_position last_known_event_position resolve_link_tos start_from message_timeout_milliseconds extra_statistics max_retry_count live_buffer_size buffer_size read_batch_size check_point_after_milliseconds min_check_point_count max_check_point_count read_buffer_count live_buffer_count retry_buffer_count total_in_flight_messages outstanding_messages_count named_consumer_strategy max_subscriber_count parked_message_count -> { event_source; group_name; status; connections; average_per_second; total_items; count_since_last_measurement; last_checkpointed_event_position; last_known_event_position; resolve_link_tos; start_from; message_timeout_milliseconds; extra_statistics; max_retry_count; live_buffer_size; buffer_size; read_batch_size; check_point_after_milliseconds; min_check_point_count; max_check_point_count; read_buffer_count; live_buffer_count; retry_buffer_count; total_in_flight_messages; outstanding_messages_count; named_consumer_strategy; max_subscriber_count; parked_message_count } in
          let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> SubscriptionInfo.ConnectionInfo.from_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: basic (6, int64_int, proto3) ^:: basic (7, int64_int, proto3) ^:: basic (8, string, proto3) ^:: basic (9, string, proto3) ^:: basic (10, bool, proto3) ^:: basic (11, string, proto3) ^:: basic (12, int32_int, proto3) ^:: basic (13, bool, proto3) ^:: basic (14, int32_int, proto3) ^:: basic (15, int32_int, proto3) ^:: basic (16, int32_int, proto3) ^:: basic (17, int32_int, proto3) ^:: basic (18, int32_int, proto3) ^:: basic (19, int32_int, proto3) ^:: basic (20, int32_int, proto3) ^:: basic (21, int32_int, proto3) ^:: basic (22, int64_int, proto3) ^:: basic (23, int32_int, proto3) ^:: basic (24, int32_int, proto3) ^:: basic (25, int32_int, proto3) ^:: basic (26, string, proto3) ^:: basic (27, int32_int, proto3) ^:: basic (28, int64_int, proto3) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ReplayParkedReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { group_name: string; stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; stop_at_option: [ `not_set | `Stop_at of int | `No_limit of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?group_name:string -> ?stream_option:[ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?stop_at_option:[ `not_set | `Stop_at of int | `No_limit of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = ReplayParkedReq.Options.t option 
        val make : ?options:ReplayParkedReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { group_name: string; stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; stop_at_option: [ `not_set | `Stop_at of int | `No_limit of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?group_name:string -> ?stream_option:[ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?stop_at_option:[ `not_set | `Stop_at of int | `No_limit of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.ReplayParkedReq.Options"
          type t = { group_name: string; stream_option: [ `not_set | `Stream_identifier of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]; stop_at_option: [ `not_set | `Stop_at of int | `No_limit of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?group_name ?stream_option ?stop_at_option () -> 
            let group_name = match group_name with Some v -> v | None -> {||} in
            let stream_option = match stream_option with Some v -> v | None -> `not_set in
            let stop_at_option = match stop_at_option with Some v -> v | None -> `not_set in
            { group_name; stream_option; stop_at_option }
          
          let to_proto =
            let apply = fun ~f:f' { group_name; stream_option; stop_at_option } -> f' [] group_name stream_option stop_at_option in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream_identifier v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t)), v) | `All v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stop_at v -> oneof_elem (4, int64_int, v) | `No_limit v -> oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions group_name stream_option stop_at_option -> { group_name; stream_option; stop_at_option } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: oneof ([ oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t)), fun v -> `Stream_identifier v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `All v) ]) ^:: oneof ([ oneof_elem (4, int64_int, fun v -> `Stop_at v); oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_limit v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "persistent.event_store.client.persistent_subscriptions.ReplayParkedReq"
        type t = ReplayParkedReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ReplayParkedReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ReplayParkedReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ReplayParkedResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "persistent.event_store.client.persistent_subscriptions.ReplayParkedResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ListReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = [ `not_set | `List_all_subscriptions of Imported'modules.Shared.Event_store.Client.Empty.t | `List_for_stream of ListReq.StreamOption.t ] 
          val make : ?list_option:[ `not_set | `List_all_subscriptions of Imported'modules.Shared.Event_store.Client.Empty.t | `List_for_stream of ListReq.StreamOption.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and StreamOption : sig
          val name': unit -> string
          type t = [ `not_set | `Stream of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] 
          val make : ?stream_option:[ `not_set | `Stream of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = ListReq.Options.t option 
        val make : ?options:ListReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = [ `not_set | `List_all_subscriptions of Imported'modules.Shared.Event_store.Client.Empty.t | `List_for_stream of ListReq.StreamOption.t ] 
          val make : ?list_option:[ `not_set | `List_all_subscriptions of Imported'modules.Shared.Event_store.Client.Empty.t | `List_for_stream of ListReq.StreamOption.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.ListReq.Options"
          type t = [ `not_set | `List_all_subscriptions of Imported'modules.Shared.Event_store.Client.Empty.t | `List_for_stream of ListReq.StreamOption.t ]
          let make =
            fun ?list_option () -> 
            let list_option = match list_option with Some v -> v | None -> `not_set in
            list_option
          
          let to_proto =
            let apply = fun ~f:f' list_option -> f' [] list_option in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `List_all_subscriptions v -> oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `List_for_stream v -> oneof_elem (2, (message (fun t -> ListReq.StreamOption.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions list_option -> list_option in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `List_all_subscriptions v); oneof_elem (2, (message (fun t -> ListReq.StreamOption.from_proto t)), fun v -> `List_for_stream v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and StreamOption : sig
          val name': unit -> string
          type t = [ `not_set | `Stream of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] 
          val make : ?stream_option:[ `not_set | `Stream of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "persistent.event_store.client.persistent_subscriptions.ListReq.StreamOption"
          type t = [ `not_set | `Stream of Imported'modules.Shared.Event_store.Client.StreamIdentifier.t | `All of Imported'modules.Shared.Event_store.Client.Empty.t ]
          let make =
            fun ?stream_option () -> 
            let stream_option = match stream_option with Some v -> v | None -> `not_set in
            stream_option
          
          let to_proto =
            let apply = fun ~f:f' stream_option -> f' [] stream_option in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream v -> oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t)), v) | `All v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_option -> stream_option in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t)), fun v -> `Stream v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `All v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "persistent.event_store.client.persistent_subscriptions.ListReq"
        type t = ListReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ListReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ListReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ListResp : sig
        val name': unit -> string
        type t = SubscriptionInfo.t list 
        val make : ?subscriptions:SubscriptionInfo.t list -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "persistent.event_store.client.persistent_subscriptions.ListResp"
        type t = SubscriptionInfo.t list
        let make =
          fun ?subscriptions () -> 
          let subscriptions = match subscriptions with Some v -> v | None -> [] in
          subscriptions
        
        let to_proto =
          let apply = fun ~f:f' subscriptions -> f' [] subscriptions in
          let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> SubscriptionInfo.to_proto t)), not_packed) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions subscriptions -> subscriptions in
          let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> SubscriptionInfo.from_proto t)), not_packed) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      module PersistentSubscriptions = struct
        module Create = struct
          let package_name = Some "event_store.client.persistent_subscriptions"
          let service_name = "PersistentSubscriptions"
          let method_name = "Create"
          let name = "/event_store.client.persistent_subscriptions.PersistentSubscriptions/Create"
          module Request = CreateReq
          module Response = CreateResp
        end
        let create = 
          (module CreateReq : Runtime'.Service.Message with type t = CreateReq.t ), 
          (module CreateResp : Runtime'.Service.Message with type t = CreateResp.t )
        
        module Update = struct
          let package_name = Some "event_store.client.persistent_subscriptions"
          let service_name = "PersistentSubscriptions"
          let method_name = "Update"
          let name = "/event_store.client.persistent_subscriptions.PersistentSubscriptions/Update"
          module Request = UpdateReq
          module Response = UpdateResp
        end
        let update = 
          (module UpdateReq : Runtime'.Service.Message with type t = UpdateReq.t ), 
          (module UpdateResp : Runtime'.Service.Message with type t = UpdateResp.t )
        
        module Delete = struct
          let package_name = Some "event_store.client.persistent_subscriptions"
          let service_name = "PersistentSubscriptions"
          let method_name = "Delete"
          let name = "/event_store.client.persistent_subscriptions.PersistentSubscriptions/Delete"
          module Request = DeleteReq
          module Response = DeleteResp
        end
        let delete = 
          (module DeleteReq : Runtime'.Service.Message with type t = DeleteReq.t ), 
          (module DeleteResp : Runtime'.Service.Message with type t = DeleteResp.t )
        
        module Read = struct
          let package_name = Some "event_store.client.persistent_subscriptions"
          let service_name = "PersistentSubscriptions"
          let method_name = "Read"
          let name = "/event_store.client.persistent_subscriptions.PersistentSubscriptions/Read"
          module Request = ReadReq
          module Response = ReadResp
        end
        let read = 
          (module ReadReq : Runtime'.Service.Message with type t = ReadReq.t ), 
          (module ReadResp : Runtime'.Service.Message with type t = ReadResp.t )
        
        module GetInfo = struct
          let package_name = Some "event_store.client.persistent_subscriptions"
          let service_name = "PersistentSubscriptions"
          let method_name = "GetInfo"
          let name = "/event_store.client.persistent_subscriptions.PersistentSubscriptions/GetInfo"
          module Request = GetInfoReq
          module Response = GetInfoResp
        end
        let getInfo = 
          (module GetInfoReq : Runtime'.Service.Message with type t = GetInfoReq.t ), 
          (module GetInfoResp : Runtime'.Service.Message with type t = GetInfoResp.t )
        
        module ReplayParked = struct
          let package_name = Some "event_store.client.persistent_subscriptions"
          let service_name = "PersistentSubscriptions"
          let method_name = "ReplayParked"
          let name = "/event_store.client.persistent_subscriptions.PersistentSubscriptions/ReplayParked"
          module Request = ReplayParkedReq
          module Response = ReplayParkedResp
        end
        let replayParked = 
          (module ReplayParkedReq : Runtime'.Service.Message with type t = ReplayParkedReq.t ), 
          (module ReplayParkedResp : Runtime'.Service.Message with type t = ReplayParkedResp.t )
        
        module List = struct
          let package_name = Some "event_store.client.persistent_subscriptions"
          let service_name = "PersistentSubscriptions"
          let method_name = "List"
          let name = "/event_store.client.persistent_subscriptions.PersistentSubscriptions/List"
          module Request = ListReq
          module Response = ListResp
        end
        let list = 
          (module ListReq : Runtime'.Service.Message with type t = ListReq.t ), 
          (module ListResp : Runtime'.Service.Message with type t = ListResp.t )
        
        module RestartSubsystem = struct
          let package_name = Some "event_store.client.persistent_subscriptions"
          let service_name = "PersistentSubscriptions"
          let method_name = "RestartSubsystem"
          let name = "/event_store.client.persistent_subscriptions.PersistentSubscriptions/RestartSubsystem"
          module Request = Imported'modules.Shared.Event_store.Client.Empty
          module Response = Imported'modules.Shared.Event_store.Client.Empty
        end
        let restartSubsystem = 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t ), 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
        
      end
    end
  end
end