(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: users.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
module Event_store = struct
  module Client = struct
    module Users = struct
      module rec CreateReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { login_name: string; password: string; full_name: string; groups: string list } 
          val make : ?login_name:string -> ?password:string -> ?full_name:string -> ?groups:string list -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = CreateReq.Options.t option 
        val make : ?options:CreateReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { login_name: string; password: string; full_name: string; groups: string list } 
          val make : ?login_name:string -> ?password:string -> ?full_name:string -> ?groups:string list -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "users.event_store.client.users.CreateReq.Options"
          type t = { login_name: string; password: string; full_name: string; groups: string list }
          let make =
            fun ?login_name ?password ?full_name ?groups () -> 
            let login_name = match login_name with Some v -> v | None -> {||} in
            let password = match password with Some v -> v | None -> {||} in
            let full_name = match full_name with Some v -> v | None -> {||} in
            let groups = match groups with Some v -> v | None -> [] in
            { login_name; password; full_name; groups }
          
          let to_proto =
            let apply = fun ~f:f' { login_name; password; full_name; groups } -> f' [] login_name password full_name groups in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, string, packed) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions login_name password full_name groups -> { login_name; password; full_name; groups } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, string, packed) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "users.event_store.client.users.CreateReq"
        type t = CreateReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> CreateReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> CreateReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and CreateResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "users.event_store.client.users.CreateResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and UpdateReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { login_name: string; password: string; full_name: string; groups: string list } 
          val make : ?login_name:string -> ?password:string -> ?full_name:string -> ?groups:string list -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = UpdateReq.Options.t option 
        val make : ?options:UpdateReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { login_name: string; password: string; full_name: string; groups: string list } 
          val make : ?login_name:string -> ?password:string -> ?full_name:string -> ?groups:string list -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "users.event_store.client.users.UpdateReq.Options"
          type t = { login_name: string; password: string; full_name: string; groups: string list }
          let make =
            fun ?login_name ?password ?full_name ?groups () -> 
            let login_name = match login_name with Some v -> v | None -> {||} in
            let password = match password with Some v -> v | None -> {||} in
            let full_name = match full_name with Some v -> v | None -> {||} in
            let groups = match groups with Some v -> v | None -> [] in
            { login_name; password; full_name; groups }
          
          let to_proto =
            let apply = fun ~f:f' { login_name; password; full_name; groups } -> f' [] login_name password full_name groups in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, string, packed) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions login_name password full_name groups -> { login_name; password; full_name; groups } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, string, packed) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "users.event_store.client.users.UpdateReq"
        type t = UpdateReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> UpdateReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> UpdateReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and UpdateResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "users.event_store.client.users.UpdateResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DeleteReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?login_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = DeleteReq.Options.t option 
        val make : ?options:DeleteReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?login_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "users.event_store.client.users.DeleteReq.Options"
          type t = string
          let make =
            fun ?login_name () -> 
            let login_name = match login_name with Some v -> v | None -> {||} in
            login_name
          
          let to_proto =
            let apply = fun ~f:f' login_name -> f' [] login_name in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions login_name -> login_name in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "users.event_store.client.users.DeleteReq"
        type t = DeleteReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> DeleteReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> DeleteReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DeleteResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "users.event_store.client.users.DeleteResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and EnableReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?login_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = EnableReq.Options.t option 
        val make : ?options:EnableReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?login_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "users.event_store.client.users.EnableReq.Options"
          type t = string
          let make =
            fun ?login_name () -> 
            let login_name = match login_name with Some v -> v | None -> {||} in
            login_name
          
          let to_proto =
            let apply = fun ~f:f' login_name -> f' [] login_name in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions login_name -> login_name in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "users.event_store.client.users.EnableReq"
        type t = EnableReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> EnableReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> EnableReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and EnableResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "users.event_store.client.users.EnableResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DisableReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?login_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = DisableReq.Options.t option 
        val make : ?options:DisableReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?login_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "users.event_store.client.users.DisableReq.Options"
          type t = string
          let make =
            fun ?login_name () -> 
            let login_name = match login_name with Some v -> v | None -> {||} in
            login_name
          
          let to_proto =
            let apply = fun ~f:f' login_name -> f' [] login_name in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions login_name -> login_name in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "users.event_store.client.users.DisableReq"
        type t = DisableReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> DisableReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> DisableReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DisableResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "users.event_store.client.users.DisableResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DetailsReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?login_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = DetailsReq.Options.t option 
        val make : ?options:DetailsReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?login_name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "users.event_store.client.users.DetailsReq.Options"
          type t = string
          let make =
            fun ?login_name () -> 
            let login_name = match login_name with Some v -> v | None -> {||} in
            login_name
          
          let to_proto =
            let apply = fun ~f:f' login_name -> f' [] login_name in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions login_name -> login_name in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "users.event_store.client.users.DetailsReq"
        type t = DetailsReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> DetailsReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> DetailsReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DetailsResp : sig
        module rec UserDetails : sig
          module rec DateTime : sig
            val name': unit -> string
            type t = int 
            val make : ?ticks_since_epoch:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { login_name: string; full_name: string; groups: string list; last_updated: DetailsResp.UserDetails.DateTime.t option; disabled: bool } 
          val make : ?login_name:string -> ?full_name:string -> ?groups:string list -> ?last_updated:DetailsResp.UserDetails.DateTime.t -> ?disabled:bool -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = DetailsResp.UserDetails.t option 
        val make : ?user_details:DetailsResp.UserDetails.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec UserDetails : sig
          module rec DateTime : sig
            val name': unit -> string
            type t = int 
            val make : ?ticks_since_epoch:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { login_name: string; full_name: string; groups: string list; last_updated: DetailsResp.UserDetails.DateTime.t option; disabled: bool } 
          val make : ?login_name:string -> ?full_name:string -> ?groups:string list -> ?last_updated:DetailsResp.UserDetails.DateTime.t -> ?disabled:bool -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec DateTime : sig
            val name': unit -> string
            type t = int 
            val make : ?ticks_since_epoch:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "users.event_store.client.users.DetailsResp.UserDetails.DateTime"
            type t = int
            let make =
              fun ?ticks_since_epoch () -> 
              let ticks_since_epoch = match ticks_since_epoch with Some v -> v | None -> 0 in
              ticks_since_epoch
            
            let to_proto =
              let apply = fun ~f:f' ticks_since_epoch -> f' [] ticks_since_epoch in
              let spec = Runtime'.Serialize.C.( basic (1, int64_int, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions ticks_since_epoch -> ticks_since_epoch in
              let spec = Runtime'.Deserialize.C.( basic (1, int64_int, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          let name' () = "users.event_store.client.users.DetailsResp.UserDetails"
          type t = { login_name: string; full_name: string; groups: string list; last_updated: DetailsResp.UserDetails.DateTime.t option; disabled: bool }
          let make =
            fun ?login_name ?full_name ?groups ?last_updated ?disabled () -> 
            let login_name = match login_name with Some v -> v | None -> {||} in
            let full_name = match full_name with Some v -> v | None -> {||} in
            let groups = match groups with Some v -> v | None -> [] in
            let disabled = match disabled with Some v -> v | None -> false in
            { login_name; full_name; groups; last_updated; disabled }
          
          let to_proto =
            let apply = fun ~f:f' { login_name; full_name; groups; last_updated; disabled } -> f' [] login_name full_name groups last_updated disabled in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, string, packed) ^:: basic_opt (4, (message (fun t -> DetailsResp.UserDetails.DateTime.to_proto t))) ^:: basic (5, bool, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions login_name full_name groups last_updated disabled -> { login_name; full_name; groups; last_updated; disabled } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, string, packed) ^:: basic_opt (4, (message (fun t -> DetailsResp.UserDetails.DateTime.from_proto t))) ^:: basic (5, bool, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "users.event_store.client.users.DetailsResp"
        type t = DetailsResp.UserDetails.t option
        let make =
          fun ?user_details () -> 
          
          user_details
        
        let to_proto =
          let apply = fun ~f:f' user_details -> f' [] user_details in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> DetailsResp.UserDetails.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions user_details -> user_details in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> DetailsResp.UserDetails.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ChangePasswordReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { login_name: string; current_password: string; new_password: string } 
          val make : ?login_name:string -> ?current_password:string -> ?new_password:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = ChangePasswordReq.Options.t option 
        val make : ?options:ChangePasswordReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { login_name: string; current_password: string; new_password: string } 
          val make : ?login_name:string -> ?current_password:string -> ?new_password:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "users.event_store.client.users.ChangePasswordReq.Options"
          type t = { login_name: string; current_password: string; new_password: string }
          let make =
            fun ?login_name ?current_password ?new_password () -> 
            let login_name = match login_name with Some v -> v | None -> {||} in
            let current_password = match current_password with Some v -> v | None -> {||} in
            let new_password = match new_password with Some v -> v | None -> {||} in
            { login_name; current_password; new_password }
          
          let to_proto =
            let apply = fun ~f:f' { login_name; current_password; new_password } -> f' [] login_name current_password new_password in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions login_name current_password new_password -> { login_name; current_password; new_password } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "users.event_store.client.users.ChangePasswordReq"
        type t = ChangePasswordReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ChangePasswordReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ChangePasswordReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ChangePasswordResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "users.event_store.client.users.ChangePasswordResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ResetPasswordReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { login_name: string; new_password: string } 
          val make : ?login_name:string -> ?new_password:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = ResetPasswordReq.Options.t option 
        val make : ?options:ResetPasswordReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { login_name: string; new_password: string } 
          val make : ?login_name:string -> ?new_password:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "users.event_store.client.users.ResetPasswordReq.Options"
          type t = { login_name: string; new_password: string }
          let make =
            fun ?login_name ?new_password () -> 
            let login_name = match login_name with Some v -> v | None -> {||} in
            let new_password = match new_password with Some v -> v | None -> {||} in
            { login_name; new_password }
          
          let to_proto =
            let apply = fun ~f:f' { login_name; new_password } -> f' [] login_name new_password in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions login_name new_password -> { login_name; new_password } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "users.event_store.client.users.ResetPasswordReq"
        type t = ResetPasswordReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ResetPasswordReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ResetPasswordReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ResetPasswordResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "users.event_store.client.users.ResetPasswordResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      module Users = struct
        module Create = struct
          let package_name = Some "event_store.client.users"
          let service_name = "Users"
          let method_name = "Create"
          let name = "/event_store.client.users.Users/Create"
          module Request = CreateReq
          module Response = CreateResp
        end
        let create = 
          (module CreateReq : Runtime'.Service.Message with type t = CreateReq.t ), 
          (module CreateResp : Runtime'.Service.Message with type t = CreateResp.t )
        
        module Update = struct
          let package_name = Some "event_store.client.users"
          let service_name = "Users"
          let method_name = "Update"
          let name = "/event_store.client.users.Users/Update"
          module Request = UpdateReq
          module Response = UpdateResp
        end
        let update = 
          (module UpdateReq : Runtime'.Service.Message with type t = UpdateReq.t ), 
          (module UpdateResp : Runtime'.Service.Message with type t = UpdateResp.t )
        
        module Delete = struct
          let package_name = Some "event_store.client.users"
          let service_name = "Users"
          let method_name = "Delete"
          let name = "/event_store.client.users.Users/Delete"
          module Request = DeleteReq
          module Response = DeleteResp
        end
        let delete = 
          (module DeleteReq : Runtime'.Service.Message with type t = DeleteReq.t ), 
          (module DeleteResp : Runtime'.Service.Message with type t = DeleteResp.t )
        
        module Disable = struct
          let package_name = Some "event_store.client.users"
          let service_name = "Users"
          let method_name = "Disable"
          let name = "/event_store.client.users.Users/Disable"
          module Request = DisableReq
          module Response = DisableResp
        end
        let disable = 
          (module DisableReq : Runtime'.Service.Message with type t = DisableReq.t ), 
          (module DisableResp : Runtime'.Service.Message with type t = DisableResp.t )
        
        module Enable = struct
          let package_name = Some "event_store.client.users"
          let service_name = "Users"
          let method_name = "Enable"
          let name = "/event_store.client.users.Users/Enable"
          module Request = EnableReq
          module Response = EnableResp
        end
        let enable = 
          (module EnableReq : Runtime'.Service.Message with type t = EnableReq.t ), 
          (module EnableResp : Runtime'.Service.Message with type t = EnableResp.t )
        
        module Details = struct
          let package_name = Some "event_store.client.users"
          let service_name = "Users"
          let method_name = "Details"
          let name = "/event_store.client.users.Users/Details"
          module Request = DetailsReq
          module Response = DetailsResp
        end
        let details = 
          (module DetailsReq : Runtime'.Service.Message with type t = DetailsReq.t ), 
          (module DetailsResp : Runtime'.Service.Message with type t = DetailsResp.t )
        
        module ChangePassword = struct
          let package_name = Some "event_store.client.users"
          let service_name = "Users"
          let method_name = "ChangePassword"
          let name = "/event_store.client.users.Users/ChangePassword"
          module Request = ChangePasswordReq
          module Response = ChangePasswordResp
        end
        let changePassword = 
          (module ChangePasswordReq : Runtime'.Service.Message with type t = ChangePasswordReq.t ), 
          (module ChangePasswordResp : Runtime'.Service.Message with type t = ChangePasswordResp.t )
        
        module ResetPassword = struct
          let package_name = Some "event_store.client.users"
          let service_name = "Users"
          let method_name = "ResetPassword"
          let name = "/event_store.client.users.Users/ResetPassword"
          module Request = ResetPasswordReq
          module Response = ResetPasswordResp
        end
        let resetPassword = 
          (module ResetPasswordReq : Runtime'.Service.Message with type t = ResetPasswordReq.t ), 
          (module ResetPasswordResp : Runtime'.Service.Message with type t = ResetPasswordResp.t )
        
      end
    end
  end
end