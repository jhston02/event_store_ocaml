(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: operations.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Shared = Shared
end
(**/**)
module Event_store = struct
  module Client = struct
    module Operations = struct
      module rec StartScavengeReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { thread_count: int; start_from_chunk: int } 
          val make : ?thread_count:int -> ?start_from_chunk:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = StartScavengeReq.Options.t option 
        val make : ?options:StartScavengeReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { thread_count: int; start_from_chunk: int } 
          val make : ?thread_count:int -> ?start_from_chunk:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "operations.event_store.client.operations.StartScavengeReq.Options"
          type t = { thread_count: int; start_from_chunk: int }
          let make =
            fun ?thread_count ?start_from_chunk () -> 
            let thread_count = match thread_count with Some v -> v | None -> 0 in
            let start_from_chunk = match start_from_chunk with Some v -> v | None -> 0 in
            { thread_count; start_from_chunk }
          
          let to_proto =
            let apply = fun ~f:f' { thread_count; start_from_chunk } -> f' [] thread_count start_from_chunk in
            let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: basic (2, int32_int, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions thread_count start_from_chunk -> { thread_count; start_from_chunk } in
            let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: basic (2, int32_int, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "operations.event_store.client.operations.StartScavengeReq"
        type t = StartScavengeReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> StartScavengeReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> StartScavengeReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and StopScavengeReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?scavenge_id:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = StopScavengeReq.Options.t option 
        val make : ?options:StopScavengeReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?scavenge_id:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "operations.event_store.client.operations.StopScavengeReq.Options"
          type t = string
          let make =
            fun ?scavenge_id () -> 
            let scavenge_id = match scavenge_id with Some v -> v | None -> {||} in
            scavenge_id
          
          let to_proto =
            let apply = fun ~f:f' scavenge_id -> f' [] scavenge_id in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions scavenge_id -> scavenge_id in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "operations.event_store.client.operations.StopScavengeReq"
        type t = StopScavengeReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> StopScavengeReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> StopScavengeReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ScavengeResp : sig
        module rec ScavengeResult : sig
          type t = Started | InProgress | Stopped 
          val to_int: t -> int
          val from_int: int -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = { scavenge_id: string; scavenge_result: ScavengeResp.ScavengeResult.t } 
        val make : ?scavenge_id:string -> ?scavenge_result:ScavengeResp.ScavengeResult.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec ScavengeResult : sig
          type t = Started | InProgress | Stopped 
          val to_int: t -> int
          val from_int: int -> (t, [> Runtime'.Result.error]) result
        end = struct 
          type t = Started | InProgress | Stopped 
          let to_int = function
            | Started -> 0
            | InProgress -> 1
            | Stopped -> 2
          
          let from_int = function
            | 0 -> Ok Started
            | 1 -> Ok InProgress
            | 2 -> Ok Stopped
            | n -> Error (`Unknown_enum_value n)
          
        end
        let name' () = "operations.event_store.client.operations.ScavengeResp"
        type t = { scavenge_id: string; scavenge_result: ScavengeResp.ScavengeResult.t }
        let make =
          fun ?scavenge_id ?scavenge_result () -> 
          let scavenge_id = match scavenge_id with Some v -> v | None -> {||} in
          let scavenge_result = match scavenge_result with Some v -> v | None -> (ScavengeResp.ScavengeResult.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
          { scavenge_id; scavenge_result }
        
        let to_proto =
          let apply = fun ~f:f' { scavenge_id; scavenge_result } -> f' [] scavenge_id scavenge_result in
          let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, (enum ScavengeResp.ScavengeResult.to_int), proto3) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions scavenge_id scavenge_result -> { scavenge_id; scavenge_result } in
          let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, (enum ScavengeResp.ScavengeResult.from_int), proto3) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and SetNodePriorityReq : sig
        val name': unit -> string
        type t = int 
        val make : ?priority:int -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "operations.event_store.client.operations.SetNodePriorityReq"
        type t = int
        let make =
          fun ?priority () -> 
          let priority = match priority with Some v -> v | None -> 0 in
          priority
        
        let to_proto =
          let apply = fun ~f:f' priority -> f' [] priority in
          let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions priority -> priority in
          let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      module Operations = struct
        module StartScavenge = struct
          let package_name = Some "event_store.client.operations"
          let service_name = "Operations"
          let method_name = "StartScavenge"
          let name = "/event_store.client.operations.Operations/StartScavenge"
          module Request = StartScavengeReq
          module Response = ScavengeResp
        end
        let startScavenge = 
          (module StartScavengeReq : Runtime'.Service.Message with type t = StartScavengeReq.t ), 
          (module ScavengeResp : Runtime'.Service.Message with type t = ScavengeResp.t )
        
        module StopScavenge = struct
          let package_name = Some "event_store.client.operations"
          let service_name = "Operations"
          let method_name = "StopScavenge"
          let name = "/event_store.client.operations.Operations/StopScavenge"
          module Request = StopScavengeReq
          module Response = ScavengeResp
        end
        let stopScavenge = 
          (module StopScavengeReq : Runtime'.Service.Message with type t = StopScavengeReq.t ), 
          (module ScavengeResp : Runtime'.Service.Message with type t = ScavengeResp.t )
        
        module Shutdown = struct
          let package_name = Some "event_store.client.operations"
          let service_name = "Operations"
          let method_name = "Shutdown"
          let name = "/event_store.client.operations.Operations/Shutdown"
          module Request = Imported'modules.Shared.Event_store.Client.Empty
          module Response = Imported'modules.Shared.Event_store.Client.Empty
        end
        let shutdown = 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t ), 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
        
        module MergeIndexes = struct
          let package_name = Some "event_store.client.operations"
          let service_name = "Operations"
          let method_name = "MergeIndexes"
          let name = "/event_store.client.operations.Operations/MergeIndexes"
          module Request = Imported'modules.Shared.Event_store.Client.Empty
          module Response = Imported'modules.Shared.Event_store.Client.Empty
        end
        let mergeIndexes = 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t ), 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
        
        module ResignNode = struct
          let package_name = Some "event_store.client.operations"
          let service_name = "Operations"
          let method_name = "ResignNode"
          let name = "/event_store.client.operations.Operations/ResignNode"
          module Request = Imported'modules.Shared.Event_store.Client.Empty
          module Response = Imported'modules.Shared.Event_store.Client.Empty
        end
        let resignNode = 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t ), 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
        
        module SetNodePriority = struct
          let package_name = Some "event_store.client.operations"
          let service_name = "Operations"
          let method_name = "SetNodePriority"
          let name = "/event_store.client.operations.Operations/SetNodePriority"
          module Request = SetNodePriorityReq
          module Response = Imported'modules.Shared.Event_store.Client.Empty
        end
        let setNodePriority = 
          (module SetNodePriorityReq : Runtime'.Service.Message with type t = SetNodePriorityReq.t ), 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
        
        module RestartPersistentSubscriptions = struct
          let package_name = Some "event_store.client.operations"
          let service_name = "Operations"
          let method_name = "RestartPersistentSubscriptions"
          let name = "/event_store.client.operations.Operations/RestartPersistentSubscriptions"
          module Request = Imported'modules.Shared.Event_store.Client.Empty
          module Response = Imported'modules.Shared.Event_store.Client.Empty
        end
        let restartPersistentSubscriptions = 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t ), 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
        
      end
    end
  end
end