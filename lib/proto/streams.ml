(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: streams.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Shared = Shared
  module Status = Status
  module Duration = Duration
  module Empty = Empty
  module Timestamp = Timestamp
end
(**/**)
module Event_store = struct
  module Client = struct
    module Streams = struct
      module rec ReadReq : sig
        module rec Options : sig
          module rec ReadDirection : sig
            type t = Forwards | Backwards 
            val to_int: t -> int
            val from_int: int -> (t, [> Runtime'.Result.error]) result
          end
          and StreamOptions : sig
            val name': unit -> string
            type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
            val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?revision_option:[ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and AllOptions : sig
            val name': unit -> string
            type t = [ `not_set | `Position of ReadReq.Options.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] 
            val make : ?all_option:[ `not_set | `Position of ReadReq.Options.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and SubscriptionOptions : sig
            val name': unit -> string
            type t = unit 
            val make : unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and Position : sig
            val name': unit -> string
            type t = { commit_position: int; prepare_position: int } 
            val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and FilterOptions : sig
            module rec Expression : sig
              val name': unit -> string
              type t = { regex: string; prefix: string list } 
              val make : ?regex:string -> ?prefix:string list -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { filter: [ `not_set | `Stream_identifier of ReadReq.Options.FilterOptions.Expression.t | `Event_type of ReadReq.Options.FilterOptions.Expression.t ]; window: [ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ]; checkpointIntervalMultiplier: int } 
            val make : ?filter:[ `not_set | `Stream_identifier of ReadReq.Options.FilterOptions.Expression.t | `Event_type of ReadReq.Options.FilterOptions.Expression.t ] -> ?window:[ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?checkpointIntervalMultiplier:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and UUIDOption : sig
            val name': unit -> string
            type t = [ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] 
            val make : ?content:[ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and ControlOption : sig
            val name': unit -> string
            type t = int 
            val make : ?compatibility:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream of ReadReq.Options.StreamOptions.t | `All of ReadReq.Options.AllOptions.t ]; read_direction: ReadReq.Options.ReadDirection.t; resolve_links: bool; count_option: [ `not_set | `Count of int | `Subscription of ReadReq.Options.SubscriptionOptions.t ]; filter_option: [ `not_set | `Filter of ReadReq.Options.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ]; uuid_option: ReadReq.Options.UUIDOption.t option; control_option: ReadReq.Options.ControlOption.t option } 
          val make : ?stream_option:[ `not_set | `Stream of ReadReq.Options.StreamOptions.t | `All of ReadReq.Options.AllOptions.t ] -> ?read_direction:ReadReq.Options.ReadDirection.t -> ?resolve_links:bool -> ?count_option:[ `not_set | `Count of int | `Subscription of ReadReq.Options.SubscriptionOptions.t ] -> ?filter_option:[ `not_set | `Filter of ReadReq.Options.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?uuid_option:ReadReq.Options.UUIDOption.t -> ?control_option:ReadReq.Options.ControlOption.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = ReadReq.Options.t option 
        val make : ?options:ReadReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          module rec ReadDirection : sig
            type t = Forwards | Backwards 
            val to_int: t -> int
            val from_int: int -> (t, [> Runtime'.Result.error]) result
          end
          and StreamOptions : sig
            val name': unit -> string
            type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
            val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?revision_option:[ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and AllOptions : sig
            val name': unit -> string
            type t = [ `not_set | `Position of ReadReq.Options.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] 
            val make : ?all_option:[ `not_set | `Position of ReadReq.Options.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and SubscriptionOptions : sig
            val name': unit -> string
            type t = unit 
            val make : unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and Position : sig
            val name': unit -> string
            type t = { commit_position: int; prepare_position: int } 
            val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and FilterOptions : sig
            module rec Expression : sig
              val name': unit -> string
              type t = { regex: string; prefix: string list } 
              val make : ?regex:string -> ?prefix:string list -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { filter: [ `not_set | `Stream_identifier of ReadReq.Options.FilterOptions.Expression.t | `Event_type of ReadReq.Options.FilterOptions.Expression.t ]; window: [ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ]; checkpointIntervalMultiplier: int } 
            val make : ?filter:[ `not_set | `Stream_identifier of ReadReq.Options.FilterOptions.Expression.t | `Event_type of ReadReq.Options.FilterOptions.Expression.t ] -> ?window:[ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?checkpointIntervalMultiplier:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and UUIDOption : sig
            val name': unit -> string
            type t = [ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] 
            val make : ?content:[ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and ControlOption : sig
            val name': unit -> string
            type t = int 
            val make : ?compatibility:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { stream_option: [ `not_set | `Stream of ReadReq.Options.StreamOptions.t | `All of ReadReq.Options.AllOptions.t ]; read_direction: ReadReq.Options.ReadDirection.t; resolve_links: bool; count_option: [ `not_set | `Count of int | `Subscription of ReadReq.Options.SubscriptionOptions.t ]; filter_option: [ `not_set | `Filter of ReadReq.Options.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ]; uuid_option: ReadReq.Options.UUIDOption.t option; control_option: ReadReq.Options.ControlOption.t option } 
          val make : ?stream_option:[ `not_set | `Stream of ReadReq.Options.StreamOptions.t | `All of ReadReq.Options.AllOptions.t ] -> ?read_direction:ReadReq.Options.ReadDirection.t -> ?resolve_links:bool -> ?count_option:[ `not_set | `Count of int | `Subscription of ReadReq.Options.SubscriptionOptions.t ] -> ?filter_option:[ `not_set | `Filter of ReadReq.Options.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?uuid_option:ReadReq.Options.UUIDOption.t -> ?control_option:ReadReq.Options.ControlOption.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec ReadDirection : sig
            type t = Forwards | Backwards 
            val to_int: t -> int
            val from_int: int -> (t, [> Runtime'.Result.error]) result
          end = struct 
            type t = Forwards | Backwards 
            let to_int = function
              | Forwards -> 0
              | Backwards -> 1
            
            let from_int = function
              | 0 -> Ok Forwards
              | 1 -> Ok Backwards
              | n -> Error (`Unknown_enum_value n)
            
          end
          and StreamOptions : sig
            val name': unit -> string
            type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
            val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?revision_option:[ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "streams.event_store.client.streams.ReadReq.Options.StreamOptions"
            type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; revision_option: [ `not_set | `Revision of int | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] }
            let make =
              fun ?stream_identifier ?revision_option () -> 
              let revision_option = match revision_option with Some v -> v | None -> `not_set in
              { stream_identifier; revision_option }
            
            let to_proto =
              let apply = fun ~f:f' { stream_identifier; revision_option } -> f' [] stream_identifier revision_option in
              let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Revision v -> oneof_elem (2, uint64_int, v) | `Start v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `End v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions stream_identifier revision_option -> { stream_identifier; revision_option } in
              let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: oneof ([ oneof_elem (2, uint64_int, fun v -> `Revision v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Start v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `End v) ]) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          and AllOptions : sig
            val name': unit -> string
            type t = [ `not_set | `Position of ReadReq.Options.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] 
            val make : ?all_option:[ `not_set | `Position of ReadReq.Options.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "streams.event_store.client.streams.ReadReq.Options.AllOptions"
            type t = [ `not_set | `Position of ReadReq.Options.Position.t | `Start of Imported'modules.Shared.Event_store.Client.Empty.t | `End of Imported'modules.Shared.Event_store.Client.Empty.t ]
            let make =
              fun ?all_option () -> 
              let all_option = match all_option with Some v -> v | None -> `not_set in
              all_option
            
            let to_proto =
              let apply = fun ~f:f' all_option -> f' [] all_option in
              let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Position v -> oneof_elem (1, (message (fun t -> ReadReq.Options.Position.to_proto t)), v) | `Start v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `End v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions all_option -> all_option in
              let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> ReadReq.Options.Position.from_proto t)), fun v -> `Position v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Start v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `End v) ]) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          and SubscriptionOptions : sig
            val name': unit -> string
            type t = unit 
            val make : unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "streams.event_store.client.streams.ReadReq.Options.SubscriptionOptions"
            type t = unit
            let make =
              fun  () -> 
              
              ()
            
            let to_proto =
              let apply = fun ~f:f' () -> f' []  in
              let spec = Runtime'.Serialize.C.( nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions  -> () in
              let spec = Runtime'.Deserialize.C.( nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          and Position : sig
            val name': unit -> string
            type t = { commit_position: int; prepare_position: int } 
            val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "streams.event_store.client.streams.ReadReq.Options.Position"
            type t = { commit_position: int; prepare_position: int }
            let make =
              fun ?commit_position ?prepare_position () -> 
              let commit_position = match commit_position with Some v -> v | None -> 0 in
              let prepare_position = match prepare_position with Some v -> v | None -> 0 in
              { commit_position; prepare_position }
            
            let to_proto =
              let apply = fun ~f:f' { commit_position; prepare_position } -> f' [] commit_position prepare_position in
              let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions commit_position prepare_position -> { commit_position; prepare_position } in
              let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          and FilterOptions : sig
            module rec Expression : sig
              val name': unit -> string
              type t = { regex: string; prefix: string list } 
              val make : ?regex:string -> ?prefix:string list -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { filter: [ `not_set | `Stream_identifier of ReadReq.Options.FilterOptions.Expression.t | `Event_type of ReadReq.Options.FilterOptions.Expression.t ]; window: [ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ]; checkpointIntervalMultiplier: int } 
            val make : ?filter:[ `not_set | `Stream_identifier of ReadReq.Options.FilterOptions.Expression.t | `Event_type of ReadReq.Options.FilterOptions.Expression.t ] -> ?window:[ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?checkpointIntervalMultiplier:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            module rec Expression : sig
              val name': unit -> string
              type t = { regex: string; prefix: string list } 
              val make : ?regex:string -> ?prefix:string list -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end = struct 
              let name' () = "streams.event_store.client.streams.ReadReq.Options.FilterOptions.Expression"
              type t = { regex: string; prefix: string list }
              let make =
                fun ?regex ?prefix () -> 
                let regex = match regex with Some v -> v | None -> {||} in
                let prefix = match prefix with Some v -> v | None -> [] in
                { regex; prefix }
              
              let to_proto =
                let apply = fun ~f:f' { regex; prefix } -> f' [] regex prefix in
                let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, string, packed) ^:: nil ) in
                let serialize = Runtime'.Serialize.serialize [] (spec) in
                fun t -> apply ~f:serialize t
              
              let from_proto =
                let constructor = fun _extensions regex prefix -> { regex; prefix } in
                let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, string, packed) ^:: nil ) in
                let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
                fun writer -> deserialize writer |> Runtime'.Result.open_error
              
            end
            let name' () = "streams.event_store.client.streams.ReadReq.Options.FilterOptions"
            type t = { filter: [ `not_set | `Stream_identifier of ReadReq.Options.FilterOptions.Expression.t | `Event_type of ReadReq.Options.FilterOptions.Expression.t ]; window: [ `not_set | `Max of int | `Count of Imported'modules.Shared.Event_store.Client.Empty.t ]; checkpointIntervalMultiplier: int }
            let make =
              fun ?filter ?window ?checkpointIntervalMultiplier () -> 
              let filter = match filter with Some v -> v | None -> `not_set in
              let window = match window with Some v -> v | None -> `not_set in
              let checkpointIntervalMultiplier = match checkpointIntervalMultiplier with Some v -> v | None -> 0 in
              { filter; window; checkpointIntervalMultiplier }
            
            let to_proto =
              let apply = fun ~f:f' { filter; window; checkpointIntervalMultiplier } -> f' [] filter window checkpointIntervalMultiplier in
              let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream_identifier v -> oneof_elem (1, (message (fun t -> ReadReq.Options.FilterOptions.Expression.to_proto t)), v) | `Event_type v -> oneof_elem (2, (message (fun t -> ReadReq.Options.FilterOptions.Expression.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Max v -> oneof_elem (3, uint32_int, v) | `Count v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: basic (5, uint32_int, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions filter window checkpointIntervalMultiplier -> { filter; window; checkpointIntervalMultiplier } in
              let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> ReadReq.Options.FilterOptions.Expression.from_proto t)), fun v -> `Stream_identifier v); oneof_elem (2, (message (fun t -> ReadReq.Options.FilterOptions.Expression.from_proto t)), fun v -> `Event_type v) ]) ^:: oneof ([ oneof_elem (3, uint32_int, fun v -> `Max v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Count v) ]) ^:: basic (5, uint32_int, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          and UUIDOption : sig
            val name': unit -> string
            type t = [ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] 
            val make : ?content:[ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "streams.event_store.client.streams.ReadReq.Options.UUIDOption"
            type t = [ `not_set | `Structured of Imported'modules.Shared.Event_store.Client.Empty.t | `String of Imported'modules.Shared.Event_store.Client.Empty.t ]
            let make =
              fun ?content () -> 
              let content = match content with Some v -> v | None -> `not_set in
              content
            
            let to_proto =
              let apply = fun ~f:f' content -> f' [] content in
              let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Structured v -> oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `String v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions content -> content in
              let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Structured v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `String v) ]) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          and ControlOption : sig
            val name': unit -> string
            type t = int 
            val make : ?compatibility:int -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "streams.event_store.client.streams.ReadReq.Options.ControlOption"
            type t = int
            let make =
              fun ?compatibility () -> 
              let compatibility = match compatibility with Some v -> v | None -> 0 in
              compatibility
            
            let to_proto =
              let apply = fun ~f:f' compatibility -> f' [] compatibility in
              let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions compatibility -> compatibility in
              let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          let name' () = "streams.event_store.client.streams.ReadReq.Options"
          type t = { stream_option: [ `not_set | `Stream of ReadReq.Options.StreamOptions.t | `All of ReadReq.Options.AllOptions.t ]; read_direction: ReadReq.Options.ReadDirection.t; resolve_links: bool; count_option: [ `not_set | `Count of int | `Subscription of ReadReq.Options.SubscriptionOptions.t ]; filter_option: [ `not_set | `Filter of ReadReq.Options.FilterOptions.t | `No_filter of Imported'modules.Shared.Event_store.Client.Empty.t ]; uuid_option: ReadReq.Options.UUIDOption.t option; control_option: ReadReq.Options.ControlOption.t option }
          let make =
            fun ?stream_option ?read_direction ?resolve_links ?count_option ?filter_option ?uuid_option ?control_option () -> 
            let stream_option = match stream_option with Some v -> v | None -> `not_set in
            let read_direction = match read_direction with Some v -> v | None -> (ReadReq.Options.ReadDirection.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
            let resolve_links = match resolve_links with Some v -> v | None -> false in
            let count_option = match count_option with Some v -> v | None -> `not_set in
            let filter_option = match filter_option with Some v -> v | None -> `not_set in
            { stream_option; read_direction; resolve_links; count_option; filter_option; uuid_option; control_option }
          
          let to_proto =
            let apply = fun ~f:f' { stream_option; read_direction; resolve_links; count_option; filter_option; uuid_option; control_option } -> f' [] stream_option read_direction resolve_links count_option filter_option uuid_option control_option in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream v -> oneof_elem (1, (message (fun t -> ReadReq.Options.StreamOptions.to_proto t)), v) | `All v -> oneof_elem (2, (message (fun t -> ReadReq.Options.AllOptions.to_proto t)), v))) ^:: basic (3, (enum ReadReq.Options.ReadDirection.to_int), proto3) ^:: basic (4, bool, proto3) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Count v -> oneof_elem (5, uint64_int, v) | `Subscription v -> oneof_elem (6, (message (fun t -> ReadReq.Options.SubscriptionOptions.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Filter v -> oneof_elem (7, (message (fun t -> ReadReq.Options.FilterOptions.to_proto t)), v) | `No_filter v -> oneof_elem (8, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: basic_opt (9, (message (fun t -> ReadReq.Options.UUIDOption.to_proto t))) ^:: basic_opt (10, (message (fun t -> ReadReq.Options.ControlOption.to_proto t))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_option read_direction resolve_links count_option filter_option uuid_option control_option -> { stream_option; read_direction; resolve_links; count_option; filter_option; uuid_option; control_option } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> ReadReq.Options.StreamOptions.from_proto t)), fun v -> `Stream v); oneof_elem (2, (message (fun t -> ReadReq.Options.AllOptions.from_proto t)), fun v -> `All v) ]) ^:: basic (3, (enum ReadReq.Options.ReadDirection.from_int), proto3) ^:: basic (4, bool, proto3) ^:: oneof ([ oneof_elem (5, uint64_int, fun v -> `Count v); oneof_elem (6, (message (fun t -> ReadReq.Options.SubscriptionOptions.from_proto t)), fun v -> `Subscription v) ]) ^:: oneof ([ oneof_elem (7, (message (fun t -> ReadReq.Options.FilterOptions.from_proto t)), fun v -> `Filter v); oneof_elem (8, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_filter v) ]) ^:: basic_opt (9, (message (fun t -> ReadReq.Options.UUIDOption.from_proto t))) ^:: basic_opt (10, (message (fun t -> ReadReq.Options.ControlOption.from_proto t))) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.ReadReq"
        type t = ReadReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ReadReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ReadReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ReadResp : sig
        module rec CaughtUp : sig
          val name': unit -> string
          type t = unit 
          val make : unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and FellBehind : sig
          val name': unit -> string
          type t = unit 
          val make : unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and ReadEvent : sig
          module rec RecordedEvent : sig
            module rec MetadataEntry : sig
              val name': unit -> string
              type t = (string * string) 
              val make : ?key:string -> ?value:string -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int; prepare_position: int; commit_position: int; metadata: ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
            val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?stream_revision:int -> ?prepare_position:int -> ?commit_position:int -> ?metadata:ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { event: ReadResp.ReadEvent.RecordedEvent.t option; link: ReadResp.ReadEvent.RecordedEvent.t option; position: [ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?event:ReadResp.ReadEvent.RecordedEvent.t -> ?link:ReadResp.ReadEvent.RecordedEvent.t -> ?position:[ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and SubscriptionConfirmation : sig
          val name': unit -> string
          type t = string 
          val make : ?subscription_id:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and Checkpoint : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and StreamNotFound : sig
          val name': unit -> string
          type t = Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = [ `not_set | `Event of ReadResp.ReadEvent.t | `Confirmation of ReadResp.SubscriptionConfirmation.t | `Checkpoint of ReadResp.Checkpoint.t | `Stream_not_found of ReadResp.StreamNotFound.t | `First_stream_position of int | `Last_stream_position of int | `Last_all_stream_position of Imported'modules.Shared.Event_store.Client.AllStreamPosition.t | `Caught_up of ReadResp.CaughtUp.t | `Fell_behind of ReadResp.FellBehind.t ] 
        val make : ?content:[ `not_set | `Event of ReadResp.ReadEvent.t | `Confirmation of ReadResp.SubscriptionConfirmation.t | `Checkpoint of ReadResp.Checkpoint.t | `Stream_not_found of ReadResp.StreamNotFound.t | `First_stream_position of int | `Last_stream_position of int | `Last_all_stream_position of Imported'modules.Shared.Event_store.Client.AllStreamPosition.t | `Caught_up of ReadResp.CaughtUp.t | `Fell_behind of ReadResp.FellBehind.t ] -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec CaughtUp : sig
          val name': unit -> string
          type t = unit 
          val make : unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.ReadResp.CaughtUp"
          type t = unit
          let make =
            fun  () -> 
            
            ()
          
          let to_proto =
            let apply = fun ~f:f' () -> f' []  in
            let spec = Runtime'.Serialize.C.( nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions  -> () in
            let spec = Runtime'.Deserialize.C.( nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and FellBehind : sig
          val name': unit -> string
          type t = unit 
          val make : unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.ReadResp.FellBehind"
          type t = unit
          let make =
            fun  () -> 
            
            ()
          
          let to_proto =
            let apply = fun ~f:f' () -> f' []  in
            let spec = Runtime'.Serialize.C.( nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions  -> () in
            let spec = Runtime'.Deserialize.C.( nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and ReadEvent : sig
          module rec RecordedEvent : sig
            module rec MetadataEntry : sig
              val name': unit -> string
              type t = (string * string) 
              val make : ?key:string -> ?value:string -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int; prepare_position: int; commit_position: int; metadata: ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
            val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?stream_revision:int -> ?prepare_position:int -> ?commit_position:int -> ?metadata:ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { event: ReadResp.ReadEvent.RecordedEvent.t option; link: ReadResp.ReadEvent.RecordedEvent.t option; position: [ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?event:ReadResp.ReadEvent.RecordedEvent.t -> ?link:ReadResp.ReadEvent.RecordedEvent.t -> ?position:[ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec RecordedEvent : sig
            module rec MetadataEntry : sig
              val name': unit -> string
              type t = (string * string) 
              val make : ?key:string -> ?value:string -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end
            val name': unit -> string
            type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int; prepare_position: int; commit_position: int; metadata: ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
            val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?stream_revision:int -> ?prepare_position:int -> ?commit_position:int -> ?metadata:ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            module rec MetadataEntry : sig
              val name': unit -> string
              type t = (string * string) 
              val make : ?key:string -> ?value:string -> unit -> t
              val to_proto: t -> Runtime'.Writer.t
              val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
            end = struct 
              let name' () = "streams.event_store.client.streams.ReadResp.ReadEvent.RecordedEvent.MetadataEntry"
              type t = (string * string)
              let make =
                fun ?key ?value () -> 
                let key = match key with Some v -> v | None -> {||} in
                let value = match value with Some v -> v | None -> {||} in
                (key, value)
              
              let to_proto =
                let apply = fun ~f:f' (key, value) -> f' [] key value in
                let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
                let serialize = Runtime'.Serialize.serialize [] (spec) in
                fun t -> apply ~f:serialize t
              
              let from_proto =
                let constructor = fun _extensions key value -> (key, value) in
                let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
                let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
                fun writer -> deserialize writer |> Runtime'.Result.open_error
              
            end
            let name' () = "streams.event_store.client.streams.ReadResp.ReadEvent.RecordedEvent"
            type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; stream_revision: int; prepare_position: int; commit_position: int; metadata: ReadResp.ReadEvent.RecordedEvent.MetadataEntry.t list; custom_metadata: bytes; data: bytes }
            let make =
              fun ?id ?stream_identifier ?stream_revision ?prepare_position ?commit_position ?metadata ?custom_metadata ?data () -> 
              let stream_revision = match stream_revision with Some v -> v | None -> 0 in
              let prepare_position = match prepare_position with Some v -> v | None -> 0 in
              let commit_position = match commit_position with Some v -> v | None -> 0 in
              let metadata = match metadata with Some v -> v | None -> [] in
              let custom_metadata = match custom_metadata with Some v -> v | None -> (Bytes.of_string {||}) in
              let data = match data with Some v -> v | None -> (Bytes.of_string {||}) in
              { id; stream_identifier; stream_revision; prepare_position; commit_position; metadata; custom_metadata; data }
            
            let to_proto =
              let apply = fun ~f:f' { id; stream_identifier; stream_revision; prepare_position; commit_position; metadata; custom_metadata; data } -> f' [] id stream_identifier stream_revision prepare_position commit_position metadata custom_metadata data in
              let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: basic (3, uint64_int, proto3) ^:: basic (4, uint64_int, proto3) ^:: basic (5, uint64_int, proto3) ^:: repeated (6, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.MetadataEntry.to_proto t)), not_packed) ^:: basic (7, bytes, proto3) ^:: basic (8, bytes, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions id stream_identifier stream_revision prepare_position commit_position metadata custom_metadata data -> { id; stream_identifier; stream_revision; prepare_position; commit_position; metadata; custom_metadata; data } in
              let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: basic (3, uint64_int, proto3) ^:: basic (4, uint64_int, proto3) ^:: basic (5, uint64_int, proto3) ^:: repeated (6, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.MetadataEntry.from_proto t)), not_packed) ^:: basic (7, bytes, proto3) ^:: basic (8, bytes, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          let name' () = "streams.event_store.client.streams.ReadResp.ReadEvent"
          type t = { event: ReadResp.ReadEvent.RecordedEvent.t option; link: ReadResp.ReadEvent.RecordedEvent.t option; position: [ `not_set | `Commit_position of int | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?event ?link ?position () -> 
            let position = match position with Some v -> v | None -> `not_set in
            { event; link; position }
          
          let to_proto =
            let apply = fun ~f:f' { event; link; position } -> f' [] event link position in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.to_proto t))) ^:: basic_opt (2, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Commit_position v -> oneof_elem (3, uint64_int, v) | `No_position v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions event link position -> { event; link; position } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.from_proto t))) ^:: basic_opt (2, (message (fun t -> ReadResp.ReadEvent.RecordedEvent.from_proto t))) ^:: oneof ([ oneof_elem (3, uint64_int, fun v -> `Commit_position v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_position v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and SubscriptionConfirmation : sig
          val name': unit -> string
          type t = string 
          val make : ?subscription_id:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.ReadResp.SubscriptionConfirmation"
          type t = string
          let make =
            fun ?subscription_id () -> 
            let subscription_id = match subscription_id with Some v -> v | None -> {||} in
            subscription_id
          
          let to_proto =
            let apply = fun ~f:f' subscription_id -> f' [] subscription_id in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions subscription_id -> subscription_id in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and Checkpoint : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.ReadResp.Checkpoint"
          type t = { commit_position: int; prepare_position: int }
          let make =
            fun ?commit_position ?prepare_position () -> 
            let commit_position = match commit_position with Some v -> v | None -> 0 in
            let prepare_position = match prepare_position with Some v -> v | None -> 0 in
            { commit_position; prepare_position }
          
          let to_proto =
            let apply = fun ~f:f' { commit_position; prepare_position } -> f' [] commit_position prepare_position in
            let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions commit_position prepare_position -> { commit_position; prepare_position } in
            let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and StreamNotFound : sig
          val name': unit -> string
          type t = Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.ReadResp.StreamNotFound"
          type t = Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option
          let make =
            fun ?stream_identifier () -> 
            
            stream_identifier
          
          let to_proto =
            let apply = fun ~f:f' stream_identifier -> f' [] stream_identifier in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_identifier -> stream_identifier in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.ReadResp"
        type t = [ `not_set | `Event of ReadResp.ReadEvent.t | `Confirmation of ReadResp.SubscriptionConfirmation.t | `Checkpoint of ReadResp.Checkpoint.t | `Stream_not_found of ReadResp.StreamNotFound.t | `First_stream_position of int | `Last_stream_position of int | `Last_all_stream_position of Imported'modules.Shared.Event_store.Client.AllStreamPosition.t | `Caught_up of ReadResp.CaughtUp.t | `Fell_behind of ReadResp.FellBehind.t ]
        let make =
          fun ?content () -> 
          let content = match content with Some v -> v | None -> `not_set in
          content
        
        let to_proto =
          let apply = fun ~f:f' content -> f' [] content in
          let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Event v -> oneof_elem (1, (message (fun t -> ReadResp.ReadEvent.to_proto t)), v) | `Confirmation v -> oneof_elem (2, (message (fun t -> ReadResp.SubscriptionConfirmation.to_proto t)), v) | `Checkpoint v -> oneof_elem (3, (message (fun t -> ReadResp.Checkpoint.to_proto t)), v) | `Stream_not_found v -> oneof_elem (4, (message (fun t -> ReadResp.StreamNotFound.to_proto t)), v) | `First_stream_position v -> oneof_elem (5, uint64_int, v) | `Last_stream_position v -> oneof_elem (6, uint64_int, v) | `Last_all_stream_position v -> oneof_elem (7, (message (fun t -> Imported'modules.Shared.Event_store.Client.AllStreamPosition.to_proto t)), v) | `Caught_up v -> oneof_elem (8, (message (fun t -> ReadResp.CaughtUp.to_proto t)), v) | `Fell_behind v -> oneof_elem (9, (message (fun t -> ReadResp.FellBehind.to_proto t)), v))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions content -> content in
          let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> ReadResp.ReadEvent.from_proto t)), fun v -> `Event v); oneof_elem (2, (message (fun t -> ReadResp.SubscriptionConfirmation.from_proto t)), fun v -> `Confirmation v); oneof_elem (3, (message (fun t -> ReadResp.Checkpoint.from_proto t)), fun v -> `Checkpoint v); oneof_elem (4, (message (fun t -> ReadResp.StreamNotFound.from_proto t)), fun v -> `Stream_not_found v); oneof_elem (5, uint64_int, fun v -> `First_stream_position v); oneof_elem (6, uint64_int, fun v -> `Last_stream_position v); oneof_elem (7, (message (fun t -> Imported'modules.Shared.Event_store.Client.AllStreamPosition.from_proto t)), fun v -> `Last_all_stream_position v); oneof_elem (8, (message (fun t -> ReadResp.CaughtUp.from_proto t)), fun v -> `Caught_up v); oneof_elem (9, (message (fun t -> ReadResp.FellBehind.from_proto t)), fun v -> `Fell_behind v) ]) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and AppendReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_revision: [ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?expected_stream_revision:[ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and ProposedMessage : sig
          module rec MetadataEntry : sig
            val name': unit -> string
            type t = (string * string) 
            val make : ?key:string -> ?value:string -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; metadata: AppendReq.ProposedMessage.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
          val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?metadata:AppendReq.ProposedMessage.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = [ `not_set | `Options of AppendReq.Options.t | `Proposed_message of AppendReq.ProposedMessage.t ] 
        val make : ?content:[ `not_set | `Options of AppendReq.Options.t | `Proposed_message of AppendReq.ProposedMessage.t ] -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_revision: [ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?expected_stream_revision:[ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.AppendReq.Options"
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_revision: [ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?stream_identifier ?expected_stream_revision () -> 
            let expected_stream_revision = match expected_stream_revision with Some v -> v | None -> `not_set in
            { stream_identifier; expected_stream_revision }
          
          let to_proto =
            let apply = fun ~f:f' { stream_identifier; expected_stream_revision } -> f' [] stream_identifier expected_stream_revision in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Revision v -> oneof_elem (2, uint64_int, v) | `No_stream v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Any v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Stream_exists v -> oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_identifier expected_stream_revision -> { stream_identifier; expected_stream_revision } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: oneof ([ oneof_elem (2, uint64_int, fun v -> `Revision v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_stream v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Any v); oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Stream_exists v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and ProposedMessage : sig
          module rec MetadataEntry : sig
            val name': unit -> string
            type t = (string * string) 
            val make : ?key:string -> ?value:string -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; metadata: AppendReq.ProposedMessage.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
          val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?metadata:AppendReq.ProposedMessage.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec MetadataEntry : sig
            val name': unit -> string
            type t = (string * string) 
            val make : ?key:string -> ?value:string -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "streams.event_store.client.streams.AppendReq.ProposedMessage.MetadataEntry"
            type t = (string * string)
            let make =
              fun ?key ?value () -> 
              let key = match key with Some v -> v | None -> {||} in
              let value = match value with Some v -> v | None -> {||} in
              (key, value)
            
            let to_proto =
              let apply = fun ~f:f' (key, value) -> f' [] key value in
              let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions key value -> (key, value) in
              let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          let name' () = "streams.event_store.client.streams.AppendReq.ProposedMessage"
          type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; metadata: AppendReq.ProposedMessage.MetadataEntry.t list; custom_metadata: bytes; data: bytes }
          let make =
            fun ?id ?metadata ?custom_metadata ?data () -> 
            let metadata = match metadata with Some v -> v | None -> [] in
            let custom_metadata = match custom_metadata with Some v -> v | None -> (Bytes.of_string {||}) in
            let data = match data with Some v -> v | None -> (Bytes.of_string {||}) in
            { id; metadata; custom_metadata; data }
          
          let to_proto =
            let apply = fun ~f:f' { id; metadata; custom_metadata; data } -> f' [] id metadata custom_metadata data in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: repeated (2, (message (fun t -> AppendReq.ProposedMessage.MetadataEntry.to_proto t)), not_packed) ^:: basic (3, bytes, proto3) ^:: basic (4, bytes, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions id metadata custom_metadata data -> { id; metadata; custom_metadata; data } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: repeated (2, (message (fun t -> AppendReq.ProposedMessage.MetadataEntry.from_proto t)), not_packed) ^:: basic (3, bytes, proto3) ^:: basic (4, bytes, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.AppendReq"
        type t = [ `not_set | `Options of AppendReq.Options.t | `Proposed_message of AppendReq.ProposedMessage.t ]
        let make =
          fun ?content () -> 
          let content = match content with Some v -> v | None -> `not_set in
          content
        
        let to_proto =
          let apply = fun ~f:f' content -> f' [] content in
          let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Options v -> oneof_elem (1, (message (fun t -> AppendReq.Options.to_proto t)), v) | `Proposed_message v -> oneof_elem (2, (message (fun t -> AppendReq.ProposedMessage.to_proto t)), v))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions content -> content in
          let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> AppendReq.Options.from_proto t)), fun v -> `Options v); oneof_elem (2, (message (fun t -> AppendReq.ProposedMessage.from_proto t)), fun v -> `Proposed_message v) ]) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and AppendResp : sig
        module rec Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and Success : sig
          val name': unit -> string
          type t = { current_revision_option: [ `not_set | `Current_revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t ]; position_option: [ `not_set | `Position of AppendResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?current_revision_option:[ `not_set | `Current_revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?position_option:[ `not_set | `Position of AppendResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and WrongExpectedVersion : sig
          val name': unit -> string
          type t = { current_revision_option_20_6_0: [ `not_set | `Current_revision_20_6_0 of int | `No_stream_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ]; expected_revision_option_20_6_0: [ `not_set | `Expected_revision_20_6_0 of int | `Any_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ]; current_revision_option: [ `not_set | `Current_revision of int | `Current_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ]; expected_revision_option: [ `not_set | `Expected_revision of int | `Expected_any of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?current_revision_option_20_6_0:[ `not_set | `Current_revision_20_6_0 of int | `No_stream_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?expected_revision_option_20_6_0:[ `not_set | `Expected_revision_20_6_0 of int | `Any_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?current_revision_option:[ `not_set | `Current_revision of int | `Current_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?expected_revision_option:[ `not_set | `Expected_revision of int | `Expected_any of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = [ `not_set | `Success of AppendResp.Success.t | `Wrong_expected_version of AppendResp.WrongExpectedVersion.t ] 
        val make : ?result:[ `not_set | `Success of AppendResp.Success.t | `Wrong_expected_version of AppendResp.WrongExpectedVersion.t ] -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.AppendResp.Position"
          type t = { commit_position: int; prepare_position: int }
          let make =
            fun ?commit_position ?prepare_position () -> 
            let commit_position = match commit_position with Some v -> v | None -> 0 in
            let prepare_position = match prepare_position with Some v -> v | None -> 0 in
            { commit_position; prepare_position }
          
          let to_proto =
            let apply = fun ~f:f' { commit_position; prepare_position } -> f' [] commit_position prepare_position in
            let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions commit_position prepare_position -> { commit_position; prepare_position } in
            let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and Success : sig
          val name': unit -> string
          type t = { current_revision_option: [ `not_set | `Current_revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t ]; position_option: [ `not_set | `Position of AppendResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?current_revision_option:[ `not_set | `Current_revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?position_option:[ `not_set | `Position of AppendResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.AppendResp.Success"
          type t = { current_revision_option: [ `not_set | `Current_revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t ]; position_option: [ `not_set | `Position of AppendResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?current_revision_option ?position_option () -> 
            let current_revision_option = match current_revision_option with Some v -> v | None -> `not_set in
            let position_option = match position_option with Some v -> v | None -> `not_set in
            { current_revision_option; position_option }
          
          let to_proto =
            let apply = fun ~f:f' { current_revision_option; position_option } -> f' [] current_revision_option position_option in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Current_revision v -> oneof_elem (1, uint64_int, v) | `No_stream v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Position v -> oneof_elem (3, (message (fun t -> AppendResp.Position.to_proto t)), v) | `No_position v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions current_revision_option position_option -> { current_revision_option; position_option } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, uint64_int, fun v -> `Current_revision v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_stream v) ]) ^:: oneof ([ oneof_elem (3, (message (fun t -> AppendResp.Position.from_proto t)), fun v -> `Position v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_position v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and WrongExpectedVersion : sig
          val name': unit -> string
          type t = { current_revision_option_20_6_0: [ `not_set | `Current_revision_20_6_0 of int | `No_stream_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ]; expected_revision_option_20_6_0: [ `not_set | `Expected_revision_20_6_0 of int | `Any_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ]; current_revision_option: [ `not_set | `Current_revision of int | `Current_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ]; expected_revision_option: [ `not_set | `Expected_revision of int | `Expected_any of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?current_revision_option_20_6_0:[ `not_set | `Current_revision_20_6_0 of int | `No_stream_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?expected_revision_option_20_6_0:[ `not_set | `Expected_revision_20_6_0 of int | `Any_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?current_revision_option:[ `not_set | `Current_revision of int | `Current_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ] -> ?expected_revision_option:[ `not_set | `Expected_revision of int | `Expected_any of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.AppendResp.WrongExpectedVersion"
          type t = { current_revision_option_20_6_0: [ `not_set | `Current_revision_20_6_0 of int | `No_stream_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ]; expected_revision_option_20_6_0: [ `not_set | `Expected_revision_20_6_0 of int | `Any_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists_20_6_0 of Imported'modules.Shared.Event_store.Client.Empty.t ]; current_revision_option: [ `not_set | `Current_revision of int | `Current_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ]; expected_revision_option: [ `not_set | `Expected_revision of int | `Expected_any of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t | `Expected_no_stream of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?current_revision_option_20_6_0 ?expected_revision_option_20_6_0 ?current_revision_option ?expected_revision_option () -> 
            let current_revision_option_20_6_0 = match current_revision_option_20_6_0 with Some v -> v | None -> `not_set in
            let expected_revision_option_20_6_0 = match expected_revision_option_20_6_0 with Some v -> v | None -> `not_set in
            let current_revision_option = match current_revision_option with Some v -> v | None -> `not_set in
            let expected_revision_option = match expected_revision_option with Some v -> v | None -> `not_set in
            { current_revision_option_20_6_0; expected_revision_option_20_6_0; current_revision_option; expected_revision_option }
          
          let to_proto =
            let apply = fun ~f:f' { current_revision_option_20_6_0; expected_revision_option_20_6_0; current_revision_option; expected_revision_option } -> f' [] current_revision_option_20_6_0 expected_revision_option_20_6_0 current_revision_option expected_revision_option in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Current_revision_20_6_0 v -> oneof_elem (1, uint64_int, v) | `No_stream_20_6_0 v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Expected_revision_20_6_0 v -> oneof_elem (3, uint64_int, v) | `Any_20_6_0 v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Stream_exists_20_6_0 v -> oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Current_revision v -> oneof_elem (6, uint64_int, v) | `Current_no_stream v -> oneof_elem (7, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Expected_revision v -> oneof_elem (8, uint64_int, v) | `Expected_any v -> oneof_elem (9, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Expected_stream_exists v -> oneof_elem (10, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Expected_no_stream v -> oneof_elem (11, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions current_revision_option_20_6_0 expected_revision_option_20_6_0 current_revision_option expected_revision_option -> { current_revision_option_20_6_0; expected_revision_option_20_6_0; current_revision_option; expected_revision_option } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, uint64_int, fun v -> `Current_revision_20_6_0 v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_stream_20_6_0 v) ]) ^:: oneof ([ oneof_elem (3, uint64_int, fun v -> `Expected_revision_20_6_0 v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Any_20_6_0 v); oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Stream_exists_20_6_0 v) ]) ^:: oneof ([ oneof_elem (6, uint64_int, fun v -> `Current_revision v); oneof_elem (7, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Current_no_stream v) ]) ^:: oneof ([ oneof_elem (8, uint64_int, fun v -> `Expected_revision v); oneof_elem (9, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Expected_any v); oneof_elem (10, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Expected_stream_exists v); oneof_elem (11, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Expected_no_stream v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.AppendResp"
        type t = [ `not_set | `Success of AppendResp.Success.t | `Wrong_expected_version of AppendResp.WrongExpectedVersion.t ]
        let make =
          fun ?result () -> 
          let result = match result with Some v -> v | None -> `not_set in
          result
        
        let to_proto =
          let apply = fun ~f:f' result -> f' [] result in
          let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Success v -> oneof_elem (1, (message (fun t -> AppendResp.Success.to_proto t)), v) | `Wrong_expected_version v -> oneof_elem (2, (message (fun t -> AppendResp.WrongExpectedVersion.to_proto t)), v))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions result -> result in
          let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> AppendResp.Success.from_proto t)), fun v -> `Success v); oneof_elem (2, (message (fun t -> AppendResp.WrongExpectedVersion.from_proto t)), fun v -> `Wrong_expected_version v) ]) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and BatchAppendReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_position: [ `not_set | `Stream_position of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t | `Any of Imported'modules.Empty.Google.Protobuf.Empty.t | `Stream_exists of Imported'modules.Empty.Google.Protobuf.Empty.t ]; deadline_option: [ `not_set | `Deadline_21_10_0 of Imported'modules.Timestamp.Google.Protobuf.Timestamp.t | `Deadline of Imported'modules.Duration.Google.Protobuf.Duration.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?expected_stream_position:[ `not_set | `Stream_position of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t | `Any of Imported'modules.Empty.Google.Protobuf.Empty.t | `Stream_exists of Imported'modules.Empty.Google.Protobuf.Empty.t ] -> ?deadline_option:[ `not_set | `Deadline_21_10_0 of Imported'modules.Timestamp.Google.Protobuf.Timestamp.t | `Deadline of Imported'modules.Duration.Google.Protobuf.Duration.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        and ProposedMessage : sig
          module rec MetadataEntry : sig
            val name': unit -> string
            type t = (string * string) 
            val make : ?key:string -> ?value:string -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; metadata: BatchAppendReq.ProposedMessage.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
          val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?metadata:BatchAppendReq.ProposedMessage.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = { correlation_id: Imported'modules.Shared.Event_store.Client.UUID.t option; options: BatchAppendReq.Options.t option; proposed_messages: BatchAppendReq.ProposedMessage.t list; is_final: bool } 
        val make : ?correlation_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?options:BatchAppendReq.Options.t -> ?proposed_messages:BatchAppendReq.ProposedMessage.t list -> ?is_final:bool -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_position: [ `not_set | `Stream_position of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t | `Any of Imported'modules.Empty.Google.Protobuf.Empty.t | `Stream_exists of Imported'modules.Empty.Google.Protobuf.Empty.t ]; deadline_option: [ `not_set | `Deadline_21_10_0 of Imported'modules.Timestamp.Google.Protobuf.Timestamp.t | `Deadline of Imported'modules.Duration.Google.Protobuf.Duration.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?expected_stream_position:[ `not_set | `Stream_position of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t | `Any of Imported'modules.Empty.Google.Protobuf.Empty.t | `Stream_exists of Imported'modules.Empty.Google.Protobuf.Empty.t ] -> ?deadline_option:[ `not_set | `Deadline_21_10_0 of Imported'modules.Timestamp.Google.Protobuf.Timestamp.t | `Deadline of Imported'modules.Duration.Google.Protobuf.Duration.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.BatchAppendReq.Options"
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_position: [ `not_set | `Stream_position of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t | `Any of Imported'modules.Empty.Google.Protobuf.Empty.t | `Stream_exists of Imported'modules.Empty.Google.Protobuf.Empty.t ]; deadline_option: [ `not_set | `Deadline_21_10_0 of Imported'modules.Timestamp.Google.Protobuf.Timestamp.t | `Deadline of Imported'modules.Duration.Google.Protobuf.Duration.t ] }
          let make =
            fun ?stream_identifier ?expected_stream_position ?deadline_option () -> 
            let expected_stream_position = match expected_stream_position with Some v -> v | None -> `not_set in
            let deadline_option = match deadline_option with Some v -> v | None -> `not_set in
            { stream_identifier; expected_stream_position; deadline_option }
          
          let to_proto =
            let apply = fun ~f:f' { stream_identifier; expected_stream_position; deadline_option } -> f' [] stream_identifier expected_stream_position deadline_option in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream_position v -> oneof_elem (2, uint64_int, v) | `No_stream v -> oneof_elem (3, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.to_proto t)), v) | `Any v -> oneof_elem (4, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.to_proto t)), v) | `Stream_exists v -> oneof_elem (5, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Deadline_21_10_0 v -> oneof_elem (6, (message (fun t -> Imported'modules.Timestamp.Google.Protobuf.Timestamp.to_proto t)), v) | `Deadline v -> oneof_elem (7, (message (fun t -> Imported'modules.Duration.Google.Protobuf.Duration.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_identifier expected_stream_position deadline_option -> { stream_identifier; expected_stream_position; deadline_option } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: oneof ([ oneof_elem (2, uint64_int, fun v -> `Stream_position v); oneof_elem (3, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.from_proto t)), fun v -> `No_stream v); oneof_elem (4, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.from_proto t)), fun v -> `Any v); oneof_elem (5, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.from_proto t)), fun v -> `Stream_exists v) ]) ^:: oneof ([ oneof_elem (6, (message (fun t -> Imported'modules.Timestamp.Google.Protobuf.Timestamp.from_proto t)), fun v -> `Deadline_21_10_0 v); oneof_elem (7, (message (fun t -> Imported'modules.Duration.Google.Protobuf.Duration.from_proto t)), fun v -> `Deadline v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        and ProposedMessage : sig
          module rec MetadataEntry : sig
            val name': unit -> string
            type t = (string * string) 
            val make : ?key:string -> ?value:string -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; metadata: BatchAppendReq.ProposedMessage.MetadataEntry.t list; custom_metadata: bytes; data: bytes } 
          val make : ?id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?metadata:BatchAppendReq.ProposedMessage.MetadataEntry.t list -> ?custom_metadata:bytes -> ?data:bytes -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec MetadataEntry : sig
            val name': unit -> string
            type t = (string * string) 
            val make : ?key:string -> ?value:string -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "streams.event_store.client.streams.BatchAppendReq.ProposedMessage.MetadataEntry"
            type t = (string * string)
            let make =
              fun ?key ?value () -> 
              let key = match key with Some v -> v | None -> {||} in
              let value = match value with Some v -> v | None -> {||} in
              (key, value)
            
            let to_proto =
              let apply = fun ~f:f' (key, value) -> f' [] key value in
              let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions key value -> (key, value) in
              let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          let name' () = "streams.event_store.client.streams.BatchAppendReq.ProposedMessage"
          type t = { id: Imported'modules.Shared.Event_store.Client.UUID.t option; metadata: BatchAppendReq.ProposedMessage.MetadataEntry.t list; custom_metadata: bytes; data: bytes }
          let make =
            fun ?id ?metadata ?custom_metadata ?data () -> 
            let metadata = match metadata with Some v -> v | None -> [] in
            let custom_metadata = match custom_metadata with Some v -> v | None -> (Bytes.of_string {||}) in
            let data = match data with Some v -> v | None -> (Bytes.of_string {||}) in
            { id; metadata; custom_metadata; data }
          
          let to_proto =
            let apply = fun ~f:f' { id; metadata; custom_metadata; data } -> f' [] id metadata custom_metadata data in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: repeated (2, (message (fun t -> BatchAppendReq.ProposedMessage.MetadataEntry.to_proto t)), not_packed) ^:: basic (3, bytes, proto3) ^:: basic (4, bytes, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions id metadata custom_metadata data -> { id; metadata; custom_metadata; data } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: repeated (2, (message (fun t -> BatchAppendReq.ProposedMessage.MetadataEntry.from_proto t)), not_packed) ^:: basic (3, bytes, proto3) ^:: basic (4, bytes, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.BatchAppendReq"
        type t = { correlation_id: Imported'modules.Shared.Event_store.Client.UUID.t option; options: BatchAppendReq.Options.t option; proposed_messages: BatchAppendReq.ProposedMessage.t list; is_final: bool }
        let make =
          fun ?correlation_id ?options ?proposed_messages ?is_final () -> 
          let proposed_messages = match proposed_messages with Some v -> v | None -> [] in
          let is_final = match is_final with Some v -> v | None -> false in
          { correlation_id; options; proposed_messages; is_final }
        
        let to_proto =
          let apply = fun ~f:f' { correlation_id; options; proposed_messages; is_final } -> f' [] correlation_id options proposed_messages is_final in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> BatchAppendReq.Options.to_proto t))) ^:: repeated (3, (message (fun t -> BatchAppendReq.ProposedMessage.to_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions correlation_id options proposed_messages is_final -> { correlation_id; options; proposed_messages; is_final } in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> BatchAppendReq.Options.from_proto t))) ^:: repeated (3, (message (fun t -> BatchAppendReq.ProposedMessage.from_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and BatchAppendResp : sig
        module rec Success : sig
          val name': unit -> string
          type t = { current_revision_option: [ `not_set | `Current_revision of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t ]; position_option: [ `not_set | `Position of Imported'modules.Shared.Event_store.Client.AllStreamPosition.t | `No_position of Imported'modules.Empty.Google.Protobuf.Empty.t ] } 
          val make : ?current_revision_option:[ `not_set | `Current_revision of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t ] -> ?position_option:[ `not_set | `Position of Imported'modules.Shared.Event_store.Client.AllStreamPosition.t | `No_position of Imported'modules.Empty.Google.Protobuf.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = { correlation_id: Imported'modules.Shared.Event_store.Client.UUID.t option; result: [ `not_set | `Error of Imported'modules.Status.Google.Rpc.Status.t | `Success of BatchAppendResp.Success.t ]; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_position: [ `not_set | `Stream_position of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t | `Any of Imported'modules.Empty.Google.Protobuf.Empty.t | `Stream_exists of Imported'modules.Empty.Google.Protobuf.Empty.t ] } 
        val make : ?correlation_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?result:[ `not_set | `Error of Imported'modules.Status.Google.Rpc.Status.t | `Success of BatchAppendResp.Success.t ] -> ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?expected_stream_position:[ `not_set | `Stream_position of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t | `Any of Imported'modules.Empty.Google.Protobuf.Empty.t | `Stream_exists of Imported'modules.Empty.Google.Protobuf.Empty.t ] -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Success : sig
          val name': unit -> string
          type t = { current_revision_option: [ `not_set | `Current_revision of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t ]; position_option: [ `not_set | `Position of Imported'modules.Shared.Event_store.Client.AllStreamPosition.t | `No_position of Imported'modules.Empty.Google.Protobuf.Empty.t ] } 
          val make : ?current_revision_option:[ `not_set | `Current_revision of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t ] -> ?position_option:[ `not_set | `Position of Imported'modules.Shared.Event_store.Client.AllStreamPosition.t | `No_position of Imported'modules.Empty.Google.Protobuf.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.BatchAppendResp.Success"
          type t = { current_revision_option: [ `not_set | `Current_revision of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t ]; position_option: [ `not_set | `Position of Imported'modules.Shared.Event_store.Client.AllStreamPosition.t | `No_position of Imported'modules.Empty.Google.Protobuf.Empty.t ] }
          let make =
            fun ?current_revision_option ?position_option () -> 
            let current_revision_option = match current_revision_option with Some v -> v | None -> `not_set in
            let position_option = match position_option with Some v -> v | None -> `not_set in
            { current_revision_option; position_option }
          
          let to_proto =
            let apply = fun ~f:f' { current_revision_option; position_option } -> f' [] current_revision_option position_option in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Current_revision v -> oneof_elem (1, uint64_int, v) | `No_stream v -> oneof_elem (2, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.to_proto t)), v))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Position v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.AllStreamPosition.to_proto t)), v) | `No_position v -> oneof_elem (4, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions current_revision_option position_option -> { current_revision_option; position_option } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, uint64_int, fun v -> `Current_revision v); oneof_elem (2, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.from_proto t)), fun v -> `No_stream v) ]) ^:: oneof ([ oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.AllStreamPosition.from_proto t)), fun v -> `Position v); oneof_elem (4, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.from_proto t)), fun v -> `No_position v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.BatchAppendResp"
        type t = { correlation_id: Imported'modules.Shared.Event_store.Client.UUID.t option; result: [ `not_set | `Error of Imported'modules.Status.Google.Rpc.Status.t | `Success of BatchAppendResp.Success.t ]; stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_position: [ `not_set | `Stream_position of int | `No_stream of Imported'modules.Empty.Google.Protobuf.Empty.t | `Any of Imported'modules.Empty.Google.Protobuf.Empty.t | `Stream_exists of Imported'modules.Empty.Google.Protobuf.Empty.t ] }
        let make =
          fun ?correlation_id ?result ?stream_identifier ?expected_stream_position () -> 
          let result = match result with Some v -> v | None -> `not_set in
          let expected_stream_position = match expected_stream_position with Some v -> v | None -> `not_set in
          { correlation_id; result; stream_identifier; expected_stream_position }
        
        let to_proto =
          let apply = fun ~f:f' { correlation_id; result; stream_identifier; expected_stream_position } -> f' [] correlation_id result stream_identifier expected_stream_position in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Error v -> oneof_elem (2, (message (fun t -> Imported'modules.Status.Google.Rpc.Status.to_proto t)), v) | `Success v -> oneof_elem (3, (message (fun t -> BatchAppendResp.Success.to_proto t)), v))) ^:: basic_opt (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Stream_position v -> oneof_elem (5, uint64_int, v) | `No_stream v -> oneof_elem (6, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.to_proto t)), v) | `Any v -> oneof_elem (7, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.to_proto t)), v) | `Stream_exists v -> oneof_elem (8, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.to_proto t)), v))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions correlation_id result stream_identifier expected_stream_position -> { correlation_id; result; stream_identifier; expected_stream_position } in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: oneof ([ oneof_elem (2, (message (fun t -> Imported'modules.Status.Google.Rpc.Status.from_proto t)), fun v -> `Error v); oneof_elem (3, (message (fun t -> BatchAppendResp.Success.from_proto t)), fun v -> `Success v) ]) ^:: basic_opt (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: oneof ([ oneof_elem (5, uint64_int, fun v -> `Stream_position v); oneof_elem (6, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.from_proto t)), fun v -> `No_stream v); oneof_elem (7, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.from_proto t)), fun v -> `Any v); oneof_elem (8, (message (fun t -> Imported'modules.Empty.Google.Protobuf.Empty.from_proto t)), fun v -> `Stream_exists v) ]) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DeleteReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_revision: [ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?expected_stream_revision:[ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = DeleteReq.Options.t option 
        val make : ?options:DeleteReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_revision: [ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?expected_stream_revision:[ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.DeleteReq.Options"
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_revision: [ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?stream_identifier ?expected_stream_revision () -> 
            let expected_stream_revision = match expected_stream_revision with Some v -> v | None -> `not_set in
            { stream_identifier; expected_stream_revision }
          
          let to_proto =
            let apply = fun ~f:f' { stream_identifier; expected_stream_revision } -> f' [] stream_identifier expected_stream_revision in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Revision v -> oneof_elem (2, uint64_int, v) | `No_stream v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Any v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Stream_exists v -> oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_identifier expected_stream_revision -> { stream_identifier; expected_stream_revision } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: oneof ([ oneof_elem (2, uint64_int, fun v -> `Revision v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_stream v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Any v); oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Stream_exists v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.DeleteReq"
        type t = DeleteReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> DeleteReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> DeleteReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DeleteResp : sig
        module rec Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = [ `not_set | `Position of DeleteResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] 
        val make : ?position_option:[ `not_set | `Position of DeleteResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.DeleteResp.Position"
          type t = { commit_position: int; prepare_position: int }
          let make =
            fun ?commit_position ?prepare_position () -> 
            let commit_position = match commit_position with Some v -> v | None -> 0 in
            let prepare_position = match prepare_position with Some v -> v | None -> 0 in
            { commit_position; prepare_position }
          
          let to_proto =
            let apply = fun ~f:f' { commit_position; prepare_position } -> f' [] commit_position prepare_position in
            let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions commit_position prepare_position -> { commit_position; prepare_position } in
            let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.DeleteResp"
        type t = [ `not_set | `Position of DeleteResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ]
        let make =
          fun ?position_option () -> 
          let position_option = match position_option with Some v -> v | None -> `not_set in
          position_option
        
        let to_proto =
          let apply = fun ~f:f' position_option -> f' [] position_option in
          let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Position v -> oneof_elem (1, (message (fun t -> DeleteResp.Position.to_proto t)), v) | `No_position v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions position_option -> position_option in
          let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> DeleteResp.Position.from_proto t)), fun v -> `Position v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_position v) ]) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and TombstoneReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_revision: [ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?expected_stream_revision:[ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = TombstoneReq.Options.t option 
        val make : ?options:TombstoneReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_revision: [ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?stream_identifier:Imported'modules.Shared.Event_store.Client.StreamIdentifier.t -> ?expected_stream_revision:[ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.TombstoneReq.Options"
          type t = { stream_identifier: Imported'modules.Shared.Event_store.Client.StreamIdentifier.t option; expected_stream_revision: [ `not_set | `Revision of int | `No_stream of Imported'modules.Shared.Event_store.Client.Empty.t | `Any of Imported'modules.Shared.Event_store.Client.Empty.t | `Stream_exists of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?stream_identifier ?expected_stream_revision () -> 
            let expected_stream_revision = match expected_stream_revision with Some v -> v | None -> `not_set in
            { stream_identifier; expected_stream_revision }
          
          let to_proto =
            let apply = fun ~f:f' { stream_identifier; expected_stream_revision } -> f' [] stream_identifier expected_stream_revision in
            let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.to_proto t))) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Revision v -> oneof_elem (2, uint64_int, v) | `No_stream v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Any v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Stream_exists v -> oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions stream_identifier expected_stream_revision -> { stream_identifier; expected_stream_revision } in
            let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.StreamIdentifier.from_proto t))) ^:: oneof ([ oneof_elem (2, uint64_int, fun v -> `Revision v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_stream v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Any v); oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Stream_exists v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.TombstoneReq"
        type t = TombstoneReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> TombstoneReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> TombstoneReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and TombstoneResp : sig
        module rec Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = [ `not_set | `Position of TombstoneResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] 
        val make : ?position_option:[ `not_set | `Position of TombstoneResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Position : sig
          val name': unit -> string
          type t = { commit_position: int; prepare_position: int } 
          val make : ?commit_position:int -> ?prepare_position:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "streams.event_store.client.streams.TombstoneResp.Position"
          type t = { commit_position: int; prepare_position: int }
          let make =
            fun ?commit_position ?prepare_position () -> 
            let commit_position = match commit_position with Some v -> v | None -> 0 in
            let prepare_position = match prepare_position with Some v -> v | None -> 0 in
            { commit_position; prepare_position }
          
          let to_proto =
            let apply = fun ~f:f' { commit_position; prepare_position } -> f' [] commit_position prepare_position in
            let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions commit_position prepare_position -> { commit_position; prepare_position } in
            let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "streams.event_store.client.streams.TombstoneResp"
        type t = [ `not_set | `Position of TombstoneResp.Position.t | `No_position of Imported'modules.Shared.Event_store.Client.Empty.t ]
        let make =
          fun ?position_option () -> 
          let position_option = match position_option with Some v -> v | None -> `not_set in
          position_option
        
        let to_proto =
          let apply = fun ~f:f' position_option -> f' [] position_option in
          let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Position v -> oneof_elem (1, (message (fun t -> TombstoneResp.Position.to_proto t)), v) | `No_position v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions position_option -> position_option in
          let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> TombstoneResp.Position.from_proto t)), fun v -> `Position v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_position v) ]) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      module Streams = struct
        module Read = struct
          let package_name = Some "event_store.client.streams"
          let service_name = "Streams"
          let method_name = "Read"
          let name = "/event_store.client.streams.Streams/Read"
          module Request = ReadReq
          module Response = ReadResp
        end
        let read = 
          (module ReadReq : Runtime'.Service.Message with type t = ReadReq.t ), 
          (module ReadResp : Runtime'.Service.Message with type t = ReadResp.t )
        
        module Append = struct
          let package_name = Some "event_store.client.streams"
          let service_name = "Streams"
          let method_name = "Append"
          let name = "/event_store.client.streams.Streams/Append"
          module Request = AppendReq
          module Response = AppendResp
        end
        let append = 
          (module AppendReq : Runtime'.Service.Message with type t = AppendReq.t ), 
          (module AppendResp : Runtime'.Service.Message with type t = AppendResp.t )
        
        module Delete = struct
          let package_name = Some "event_store.client.streams"
          let service_name = "Streams"
          let method_name = "Delete"
          let name = "/event_store.client.streams.Streams/Delete"
          module Request = DeleteReq
          module Response = DeleteResp
        end
        let delete = 
          (module DeleteReq : Runtime'.Service.Message with type t = DeleteReq.t ), 
          (module DeleteResp : Runtime'.Service.Message with type t = DeleteResp.t )
        
        module Tombstone = struct
          let package_name = Some "event_store.client.streams"
          let service_name = "Streams"
          let method_name = "Tombstone"
          let name = "/event_store.client.streams.Streams/Tombstone"
          module Request = TombstoneReq
          module Response = TombstoneResp
        end
        let tombstone = 
          (module TombstoneReq : Runtime'.Service.Message with type t = TombstoneReq.t ), 
          (module TombstoneResp : Runtime'.Service.Message with type t = TombstoneResp.t )
        
        module BatchAppend = struct
          let package_name = Some "event_store.client.streams"
          let service_name = "Streams"
          let method_name = "BatchAppend"
          let name = "/event_store.client.streams.Streams/BatchAppend"
          module Request = BatchAppendReq
          module Response = BatchAppendResp
        end
        let batchAppend = 
          (module BatchAppendReq : Runtime'.Service.Message with type t = BatchAppendReq.t ), 
          (module BatchAppendResp : Runtime'.Service.Message with type t = BatchAppendResp.t )
        
      end
    end
  end
end