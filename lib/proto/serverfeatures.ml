(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: serverfeatures.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Shared = Shared
end
(**/**)
module Event_store = struct
  module Client = struct
    module Server_features = struct
      module rec SupportedMethods : sig
        val name': unit -> string
        type t = { methods: SupportedMethod.t list; event_store_server_version: string } 
        val make : ?methods:SupportedMethod.t list -> ?event_store_server_version:string -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "serverfeatures.event_store.client.server_features.SupportedMethods"
        type t = { methods: SupportedMethod.t list; event_store_server_version: string }
        let make =
          fun ?methods ?event_store_server_version () -> 
          let methods = match methods with Some v -> v | None -> [] in
          let event_store_server_version = match event_store_server_version with Some v -> v | None -> {||} in
          { methods; event_store_server_version }
        
        let to_proto =
          let apply = fun ~f:f' { methods; event_store_server_version } -> f' [] methods event_store_server_version in
          let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> SupportedMethod.to_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions methods event_store_server_version -> { methods; event_store_server_version } in
          let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> SupportedMethod.from_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and SupportedMethod : sig
        val name': unit -> string
        type t = { method_name: string; service_name: string; features: string list } 
        val make : ?method_name:string -> ?service_name:string -> ?features:string list -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "serverfeatures.event_store.client.server_features.SupportedMethod"
        type t = { method_name: string; service_name: string; features: string list }
        let make =
          fun ?method_name ?service_name ?features () -> 
          let method_name = match method_name with Some v -> v | None -> {||} in
          let service_name = match service_name with Some v -> v | None -> {||} in
          let features = match features with Some v -> v | None -> [] in
          { method_name; service_name; features }
        
        let to_proto =
          let apply = fun ~f:f' { method_name; service_name; features } -> f' [] method_name service_name features in
          let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, string, packed) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions method_name service_name features -> { method_name; service_name; features } in
          let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, string, packed) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      module ServerFeatures = struct
        module GetSupportedMethods = struct
          let package_name = Some "event_store.client.server_features"
          let service_name = "ServerFeatures"
          let method_name = "GetSupportedMethods"
          let name = "/event_store.client.server_features.ServerFeatures/GetSupportedMethods"
          module Request = Imported'modules.Shared.Event_store.Client.Empty
          module Response = SupportedMethods
        end
        let getSupportedMethods = 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t ), 
          (module SupportedMethods : Runtime'.Service.Message with type t = SupportedMethods.t )
        
      end
    end
  end
end