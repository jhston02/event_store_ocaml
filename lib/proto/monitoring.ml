(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: monitoring.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
module Event_store = struct
  module Client = struct
    module Monitoring = struct
      module rec StatsReq : sig
        val name': unit -> string
        type t = { use_metadata: bool; refresh_time_period_in_ms: int } 
        val make : ?use_metadata:bool -> ?refresh_time_period_in_ms:int -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "monitoring.event_store.client.monitoring.StatsReq"
        type t = { use_metadata: bool; refresh_time_period_in_ms: int }
        let make =
          fun ?use_metadata ?refresh_time_period_in_ms () -> 
          let use_metadata = match use_metadata with Some v -> v | None -> false in
          let refresh_time_period_in_ms = match refresh_time_period_in_ms with Some v -> v | None -> 0 in
          { use_metadata; refresh_time_period_in_ms }
        
        let to_proto =
          let apply = fun ~f:f' { use_metadata; refresh_time_period_in_ms } -> f' [] use_metadata refresh_time_period_in_ms in
          let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (4, uint64_int, proto3) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions use_metadata refresh_time_period_in_ms -> { use_metadata; refresh_time_period_in_ms } in
          let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (4, uint64_int, proto3) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and StatsResp : sig
        module rec StatsEntry : sig
          val name': unit -> string
          type t = (string * string) 
          val make : ?key:string -> ?value:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = StatsResp.StatsEntry.t list 
        val make : ?stats:StatsResp.StatsEntry.t list -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec StatsEntry : sig
          val name': unit -> string
          type t = (string * string) 
          val make : ?key:string -> ?value:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "monitoring.event_store.client.monitoring.StatsResp.StatsEntry"
          type t = (string * string)
          let make =
            fun ?key ?value () -> 
            let key = match key with Some v -> v | None -> {||} in
            let value = match value with Some v -> v | None -> {||} in
            (key, value)
          
          let to_proto =
            let apply = fun ~f:f' (key, value) -> f' [] key value in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions key value -> (key, value) in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "monitoring.event_store.client.monitoring.StatsResp"
        type t = StatsResp.StatsEntry.t list
        let make =
          fun ?stats () -> 
          let stats = match stats with Some v -> v | None -> [] in
          stats
        
        let to_proto =
          let apply = fun ~f:f' stats -> f' [] stats in
          let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> StatsResp.StatsEntry.to_proto t)), not_packed) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions stats -> stats in
          let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> StatsResp.StatsEntry.from_proto t)), not_packed) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      module Monitoring = struct
        module Stats = struct
          let package_name = Some "event_store.client.monitoring"
          let service_name = "Monitoring"
          let method_name = "Stats"
          let name = "/event_store.client.monitoring.Monitoring/Stats"
          module Request = StatsReq
          module Response = StatsResp
        end
        let stats = 
          (module StatsReq : Runtime'.Service.Message with type t = StatsReq.t ), 
          (module StatsResp : Runtime'.Service.Message with type t = StatsResp.t )
        
      end
    end
  end
end