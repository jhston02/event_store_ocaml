(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: cluster.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Shared = Shared
end
(**/**)
module Event_store = struct
  module Cluster = struct
    module rec GossipRequest : sig
      val name': unit -> string
      type t = { info: ClusterInfo.t option; server: EndPoint.t option } 
      val make : ?info:ClusterInfo.t -> ?server:EndPoint.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.GossipRequest"
      type t = { info: ClusterInfo.t option; server: EndPoint.t option }
      let make =
        fun ?info ?server () -> 
        
        { info; server }
      
      let to_proto =
        let apply = fun ~f:f' { info; server } -> f' [] info server in
        let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ClusterInfo.to_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions info server -> { info; server } in
        let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ClusterInfo.from_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and ViewChangeRequest : sig
      val name': unit -> string
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; attempted_view: int } 
      val make : ?server_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?server_http:EndPoint.t -> ?attempted_view:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.ViewChangeRequest"
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; attempted_view: int }
      let make =
        fun ?server_id ?server_http ?attempted_view () -> 
        let attempted_view = match attempted_view with Some v -> v | None -> 0 in
        { server_id; server_http; attempted_view }
      
      let to_proto =
        let apply = fun ~f:f' { server_id; server_http; attempted_view } -> f' [] server_id server_http attempted_view in
        let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.to_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions server_id server_http attempted_view -> { server_id; server_http; attempted_view } in
        let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.from_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and ViewChangeProofRequest : sig
      val name': unit -> string
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; installed_view: int } 
      val make : ?server_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?server_http:EndPoint.t -> ?installed_view:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.ViewChangeProofRequest"
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; installed_view: int }
      let make =
        fun ?server_id ?server_http ?installed_view () -> 
        let installed_view = match installed_view with Some v -> v | None -> 0 in
        { server_id; server_http; installed_view }
      
      let to_proto =
        let apply = fun ~f:f' { server_id; server_http; installed_view } -> f' [] server_id server_http installed_view in
        let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.to_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions server_id server_http installed_view -> { server_id; server_http; installed_view } in
        let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.from_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and PrepareRequest : sig
      val name': unit -> string
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; view: int } 
      val make : ?server_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?server_http:EndPoint.t -> ?view:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.PrepareRequest"
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; view: int }
      let make =
        fun ?server_id ?server_http ?view () -> 
        let view = match view with Some v -> v | None -> 0 in
        { server_id; server_http; view }
      
      let to_proto =
        let apply = fun ~f:f' { server_id; server_http; view } -> f' [] server_id server_http view in
        let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.to_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions server_id server_http view -> { server_id; server_http; view } in
        let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.from_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and PrepareOkRequest : sig
      val name': unit -> string
      type t = { view: int; server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; epoch_number: int; epoch_position: int; epoch_id: Imported'modules.Shared.Event_store.Client.UUID.t option; epoch_leader_instance_id: Imported'modules.Shared.Event_store.Client.UUID.t option; last_commit_position: int; writer_checkpoint: int; chaser_checkpoint: int; node_priority: int; cluster_info: ClusterInfo.t option } 
      val make : ?view:int -> ?server_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?server_http:EndPoint.t -> ?epoch_number:int -> ?epoch_position:int -> ?epoch_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?epoch_leader_instance_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?last_commit_position:int -> ?writer_checkpoint:int -> ?chaser_checkpoint:int -> ?node_priority:int -> ?cluster_info:ClusterInfo.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.PrepareOkRequest"
      type t = { view: int; server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; epoch_number: int; epoch_position: int; epoch_id: Imported'modules.Shared.Event_store.Client.UUID.t option; epoch_leader_instance_id: Imported'modules.Shared.Event_store.Client.UUID.t option; last_commit_position: int; writer_checkpoint: int; chaser_checkpoint: int; node_priority: int; cluster_info: ClusterInfo.t option }
      let make =
        fun ?view ?server_id ?server_http ?epoch_number ?epoch_position ?epoch_id ?epoch_leader_instance_id ?last_commit_position ?writer_checkpoint ?chaser_checkpoint ?node_priority ?cluster_info () -> 
        let view = match view with Some v -> v | None -> 0 in
        let epoch_number = match epoch_number with Some v -> v | None -> 0 in
        let epoch_position = match epoch_position with Some v -> v | None -> 0 in
        let last_commit_position = match last_commit_position with Some v -> v | None -> 0 in
        let writer_checkpoint = match writer_checkpoint with Some v -> v | None -> 0 in
        let chaser_checkpoint = match chaser_checkpoint with Some v -> v | None -> 0 in
        let node_priority = match node_priority with Some v -> v | None -> 0 in
        { view; server_id; server_http; epoch_number; epoch_position; epoch_id; epoch_leader_instance_id; last_commit_position; writer_checkpoint; chaser_checkpoint; node_priority; cluster_info }
      
      let to_proto =
        let apply = fun ~f:f' { view; server_id; server_http; epoch_number; epoch_position; epoch_id; epoch_leader_instance_id; last_commit_position; writer_checkpoint; chaser_checkpoint; node_priority; cluster_info } -> f' [] view server_id server_http epoch_number epoch_position epoch_id epoch_leader_instance_id last_commit_position writer_checkpoint chaser_checkpoint node_priority cluster_info in
        let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (3, (message (fun t -> EndPoint.to_proto t))) ^:: basic (4, int32_int, proto3) ^:: basic (5, int64_int, proto3) ^:: basic_opt (6, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (7, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic (8, int64_int, proto3) ^:: basic (9, int64_int, proto3) ^:: basic (10, int64_int, proto3) ^:: basic (11, int32_int, proto3) ^:: basic_opt (12, (message (fun t -> ClusterInfo.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions view server_id server_http epoch_number epoch_position epoch_id epoch_leader_instance_id last_commit_position writer_checkpoint chaser_checkpoint node_priority cluster_info -> { view; server_id; server_http; epoch_number; epoch_position; epoch_id; epoch_leader_instance_id; last_commit_position; writer_checkpoint; chaser_checkpoint; node_priority; cluster_info } in
        let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (3, (message (fun t -> EndPoint.from_proto t))) ^:: basic (4, int32_int, proto3) ^:: basic (5, int64_int, proto3) ^:: basic_opt (6, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (7, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic (8, int64_int, proto3) ^:: basic (9, int64_int, proto3) ^:: basic (10, int64_int, proto3) ^:: basic (11, int32_int, proto3) ^:: basic_opt (12, (message (fun t -> ClusterInfo.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and ProposalRequest : sig
      val name': unit -> string
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; leader_id: Imported'modules.Shared.Event_store.Client.UUID.t option; leader_http: EndPoint.t option; view: int; epoch_number: int; epoch_position: int; epoch_id: Imported'modules.Shared.Event_store.Client.UUID.t option; epoch_leader_instance_id: Imported'modules.Shared.Event_store.Client.UUID.t option; last_commit_position: int; writer_checkpoint: int; chaser_checkpoint: int; node_priority: int } 
      val make : ?server_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?server_http:EndPoint.t -> ?leader_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?leader_http:EndPoint.t -> ?view:int -> ?epoch_number:int -> ?epoch_position:int -> ?epoch_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?epoch_leader_instance_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?last_commit_position:int -> ?writer_checkpoint:int -> ?chaser_checkpoint:int -> ?node_priority:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.ProposalRequest"
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; leader_id: Imported'modules.Shared.Event_store.Client.UUID.t option; leader_http: EndPoint.t option; view: int; epoch_number: int; epoch_position: int; epoch_id: Imported'modules.Shared.Event_store.Client.UUID.t option; epoch_leader_instance_id: Imported'modules.Shared.Event_store.Client.UUID.t option; last_commit_position: int; writer_checkpoint: int; chaser_checkpoint: int; node_priority: int }
      let make =
        fun ?server_id ?server_http ?leader_id ?leader_http ?view ?epoch_number ?epoch_position ?epoch_id ?epoch_leader_instance_id ?last_commit_position ?writer_checkpoint ?chaser_checkpoint ?node_priority () -> 
        let view = match view with Some v -> v | None -> 0 in
        let epoch_number = match epoch_number with Some v -> v | None -> 0 in
        let epoch_position = match epoch_position with Some v -> v | None -> 0 in
        let last_commit_position = match last_commit_position with Some v -> v | None -> 0 in
        let writer_checkpoint = match writer_checkpoint with Some v -> v | None -> 0 in
        let chaser_checkpoint = match chaser_checkpoint with Some v -> v | None -> 0 in
        let node_priority = match node_priority with Some v -> v | None -> 0 in
        { server_id; server_http; leader_id; leader_http; view; epoch_number; epoch_position; epoch_id; epoch_leader_instance_id; last_commit_position; writer_checkpoint; chaser_checkpoint; node_priority }
      
      let to_proto =
        let apply = fun ~f:f' { server_id; server_http; leader_id; leader_http; view; epoch_number; epoch_position; epoch_id; epoch_leader_instance_id; last_commit_position; writer_checkpoint; chaser_checkpoint; node_priority } -> f' [] server_id server_http leader_id leader_http view epoch_number epoch_position epoch_id epoch_leader_instance_id last_commit_position writer_checkpoint chaser_checkpoint node_priority in
        let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.to_proto t))) ^:: basic_opt (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (4, (message (fun t -> EndPoint.to_proto t))) ^:: basic (5, int32_int, proto3) ^:: basic (6, int32_int, proto3) ^:: basic (7, int64_int, proto3) ^:: basic_opt (8, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (9, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic (10, int64_int, proto3) ^:: basic (11, int64_int, proto3) ^:: basic (12, int64_int, proto3) ^:: basic (13, int32_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions server_id server_http leader_id leader_http view epoch_number epoch_position epoch_id epoch_leader_instance_id last_commit_position writer_checkpoint chaser_checkpoint node_priority -> { server_id; server_http; leader_id; leader_http; view; epoch_number; epoch_position; epoch_id; epoch_leader_instance_id; last_commit_position; writer_checkpoint; chaser_checkpoint; node_priority } in
        let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.from_proto t))) ^:: basic_opt (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (4, (message (fun t -> EndPoint.from_proto t))) ^:: basic (5, int32_int, proto3) ^:: basic (6, int32_int, proto3) ^:: basic (7, int64_int, proto3) ^:: basic_opt (8, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (9, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic (10, int64_int, proto3) ^:: basic (11, int64_int, proto3) ^:: basic (12, int64_int, proto3) ^:: basic (13, int32_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and AcceptRequest : sig
      val name': unit -> string
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; leader_id: Imported'modules.Shared.Event_store.Client.UUID.t option; leader_http: EndPoint.t option; view: int } 
      val make : ?server_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?server_http:EndPoint.t -> ?leader_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?leader_http:EndPoint.t -> ?view:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.AcceptRequest"
      type t = { server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option; leader_id: Imported'modules.Shared.Event_store.Client.UUID.t option; leader_http: EndPoint.t option; view: int }
      let make =
        fun ?server_id ?server_http ?leader_id ?leader_http ?view () -> 
        let view = match view with Some v -> v | None -> 0 in
        { server_id; server_http; leader_id; leader_http; view }
      
      let to_proto =
        let apply = fun ~f:f' { server_id; server_http; leader_id; leader_http; view } -> f' [] server_id server_http leader_id leader_http view in
        let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.to_proto t))) ^:: basic_opt (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (4, (message (fun t -> EndPoint.to_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions server_id server_http leader_id leader_http view -> { server_id; server_http; leader_id; leader_http; view } in
        let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.from_proto t))) ^:: basic_opt (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (4, (message (fun t -> EndPoint.from_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and LeaderIsResigningRequest : sig
      val name': unit -> string
      type t = { leader_id: Imported'modules.Shared.Event_store.Client.UUID.t option; leader_http: EndPoint.t option } 
      val make : ?leader_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?leader_http:EndPoint.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.LeaderIsResigningRequest"
      type t = { leader_id: Imported'modules.Shared.Event_store.Client.UUID.t option; leader_http: EndPoint.t option }
      let make =
        fun ?leader_id ?leader_http () -> 
        
        { leader_id; leader_http }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; leader_http } -> f' [] leader_id leader_http in
        let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id leader_http -> { leader_id; leader_http } in
        let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and LeaderIsResigningOkRequest : sig
      val name': unit -> string
      type t = { leader_id: Imported'modules.Shared.Event_store.Client.UUID.t option; leader_http: EndPoint.t option; server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option } 
      val make : ?leader_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?leader_http:EndPoint.t -> ?server_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?server_http:EndPoint.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.LeaderIsResigningOkRequest"
      type t = { leader_id: Imported'modules.Shared.Event_store.Client.UUID.t option; leader_http: EndPoint.t option; server_id: Imported'modules.Shared.Event_store.Client.UUID.t option; server_http: EndPoint.t option }
      let make =
        fun ?leader_id ?leader_http ?server_id ?server_http () -> 
        
        { leader_id; leader_http; server_id; server_http }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; leader_http; server_id; server_http } -> f' [] leader_id leader_http server_id server_http in
        let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.to_proto t))) ^:: basic_opt (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic_opt (4, (message (fun t -> EndPoint.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id leader_http server_id server_http -> { leader_id; leader_http; server_id; server_http } in
        let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (2, (message (fun t -> EndPoint.from_proto t))) ^:: basic_opt (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic_opt (4, (message (fun t -> EndPoint.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and ClusterInfo : sig
      val name': unit -> string
      type t = MemberInfo.t list 
      val make : ?members:MemberInfo.t list -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.ClusterInfo"
      type t = MemberInfo.t list
      let make =
        fun ?members () -> 
        let members = match members with Some v -> v | None -> [] in
        members
      
      let to_proto =
        let apply = fun ~f:f' members -> f' [] members in
        let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> MemberInfo.to_proto t)), not_packed) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions members -> members in
        let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> MemberInfo.from_proto t)), not_packed) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and EndPoint : sig
      val name': unit -> string
      type t = { address: string; port: int } 
      val make : ?address:string -> ?port:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.EndPoint"
      type t = { address: string; port: int }
      let make =
        fun ?address ?port () -> 
        let address = match address with Some v -> v | None -> {||} in
        let port = match port with Some v -> v | None -> 0 in
        { address; port }
      
      let to_proto =
        let apply = fun ~f:f' { address; port } -> f' [] address port in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, uint32_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions address port -> { address; port } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, uint32_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and MemberInfo : sig
      module rec VNodeState : sig
        type t = Initializing | DiscoverLeader | Unknown | PreReplica | CatchingUp | Clone | Follower | PreLeader | Leader | Manager | ShuttingDown | Shutdown | ReadOnlyLeaderless | PreReadOnlyReplica | ReadOnlyReplica | ResigningLeader 
        val to_int: t -> int
        val from_int: int -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { instance_id: Imported'modules.Shared.Event_store.Client.UUID.t option; time_stamp: int; state: MemberInfo.VNodeState.t; is_alive: bool; http_end_point: EndPoint.t option; internal_tcp: EndPoint.t option; external_tcp: EndPoint.t option; internal_tcp_uses_tls: bool; external_tcp_uses_tls: bool; last_commit_position: int; writer_checkpoint: int; chaser_checkpoint: int; epoch_position: int; epoch_number: int; epoch_id: Imported'modules.Shared.Event_store.Client.UUID.t option; node_priority: int; is_read_only_replica: bool; advertise_host_to_client_as: string; advertise_http_port_to_client_as: int; advertise_tcp_port_to_client_as: int; es_version: string } 
      val make : ?instance_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?time_stamp:int -> ?state:MemberInfo.VNodeState.t -> ?is_alive:bool -> ?http_end_point:EndPoint.t -> ?internal_tcp:EndPoint.t -> ?external_tcp:EndPoint.t -> ?internal_tcp_uses_tls:bool -> ?external_tcp_uses_tls:bool -> ?last_commit_position:int -> ?writer_checkpoint:int -> ?chaser_checkpoint:int -> ?epoch_position:int -> ?epoch_number:int -> ?epoch_id:Imported'modules.Shared.Event_store.Client.UUID.t -> ?node_priority:int -> ?is_read_only_replica:bool -> ?advertise_host_to_client_as:string -> ?advertise_http_port_to_client_as:int -> ?advertise_tcp_port_to_client_as:int -> ?es_version:string -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      module rec VNodeState : sig
        type t = Initializing | DiscoverLeader | Unknown | PreReplica | CatchingUp | Clone | Follower | PreLeader | Leader | Manager | ShuttingDown | Shutdown | ReadOnlyLeaderless | PreReadOnlyReplica | ReadOnlyReplica | ResigningLeader 
        val to_int: t -> int
        val from_int: int -> (t, [> Runtime'.Result.error]) result
      end = struct 
        type t = Initializing | DiscoverLeader | Unknown | PreReplica | CatchingUp | Clone | Follower | PreLeader | Leader | Manager | ShuttingDown | Shutdown | ReadOnlyLeaderless | PreReadOnlyReplica | ReadOnlyReplica | ResigningLeader 
        let to_int = function
          | Initializing -> 0
          | DiscoverLeader -> 1
          | Unknown -> 2
          | PreReplica -> 3
          | CatchingUp -> 4
          | Clone -> 5
          | Follower -> 6
          | PreLeader -> 7
          | Leader -> 8
          | Manager -> 9
          | ShuttingDown -> 10
          | Shutdown -> 11
          | ReadOnlyLeaderless -> 12
          | PreReadOnlyReplica -> 13
          | ReadOnlyReplica -> 14
          | ResigningLeader -> 15
        
        let from_int = function
          | 0 -> Ok Initializing
          | 1 -> Ok DiscoverLeader
          | 2 -> Ok Unknown
          | 3 -> Ok PreReplica
          | 4 -> Ok CatchingUp
          | 5 -> Ok Clone
          | 6 -> Ok Follower
          | 7 -> Ok PreLeader
          | 8 -> Ok Leader
          | 9 -> Ok Manager
          | 10 -> Ok ShuttingDown
          | 11 -> Ok Shutdown
          | 12 -> Ok ReadOnlyLeaderless
          | 13 -> Ok PreReadOnlyReplica
          | 14 -> Ok ReadOnlyReplica
          | 15 -> Ok ResigningLeader
          | n -> Error (`Unknown_enum_value n)
        
      end
      let name' () = "cluster.event_store.cluster.MemberInfo"
      type t = { instance_id: Imported'modules.Shared.Event_store.Client.UUID.t option; time_stamp: int; state: MemberInfo.VNodeState.t; is_alive: bool; http_end_point: EndPoint.t option; internal_tcp: EndPoint.t option; external_tcp: EndPoint.t option; internal_tcp_uses_tls: bool; external_tcp_uses_tls: bool; last_commit_position: int; writer_checkpoint: int; chaser_checkpoint: int; epoch_position: int; epoch_number: int; epoch_id: Imported'modules.Shared.Event_store.Client.UUID.t option; node_priority: int; is_read_only_replica: bool; advertise_host_to_client_as: string; advertise_http_port_to_client_as: int; advertise_tcp_port_to_client_as: int; es_version: string }
      let make =
        fun ?instance_id ?time_stamp ?state ?is_alive ?http_end_point ?internal_tcp ?external_tcp ?internal_tcp_uses_tls ?external_tcp_uses_tls ?last_commit_position ?writer_checkpoint ?chaser_checkpoint ?epoch_position ?epoch_number ?epoch_id ?node_priority ?is_read_only_replica ?advertise_host_to_client_as ?advertise_http_port_to_client_as ?advertise_tcp_port_to_client_as ?es_version () -> 
        let time_stamp = match time_stamp with Some v -> v | None -> 0 in
        let state = match state with Some v -> v | None -> (MemberInfo.VNodeState.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
        let is_alive = match is_alive with Some v -> v | None -> false in
        let internal_tcp_uses_tls = match internal_tcp_uses_tls with Some v -> v | None -> false in
        let external_tcp_uses_tls = match external_tcp_uses_tls with Some v -> v | None -> false in
        let last_commit_position = match last_commit_position with Some v -> v | None -> 0 in
        let writer_checkpoint = match writer_checkpoint with Some v -> v | None -> 0 in
        let chaser_checkpoint = match chaser_checkpoint with Some v -> v | None -> 0 in
        let epoch_position = match epoch_position with Some v -> v | None -> 0 in
        let epoch_number = match epoch_number with Some v -> v | None -> 0 in
        let node_priority = match node_priority with Some v -> v | None -> 0 in
        let is_read_only_replica = match is_read_only_replica with Some v -> v | None -> false in
        let advertise_host_to_client_as = match advertise_host_to_client_as with Some v -> v | None -> {||} in
        let advertise_http_port_to_client_as = match advertise_http_port_to_client_as with Some v -> v | None -> 0 in
        let advertise_tcp_port_to_client_as = match advertise_tcp_port_to_client_as with Some v -> v | None -> 0 in
        let es_version = match es_version with Some v -> v | None -> {||} in
        { instance_id; time_stamp; state; is_alive; http_end_point; internal_tcp; external_tcp; internal_tcp_uses_tls; external_tcp_uses_tls; last_commit_position; writer_checkpoint; chaser_checkpoint; epoch_position; epoch_number; epoch_id; node_priority; is_read_only_replica; advertise_host_to_client_as; advertise_http_port_to_client_as; advertise_tcp_port_to_client_as; es_version }
      
      let to_proto =
        let apply = fun ~f:f' { instance_id; time_stamp; state; is_alive; http_end_point; internal_tcp; external_tcp; internal_tcp_uses_tls; external_tcp_uses_tls; last_commit_position; writer_checkpoint; chaser_checkpoint; epoch_position; epoch_number; epoch_id; node_priority; is_read_only_replica; advertise_host_to_client_as; advertise_http_port_to_client_as; advertise_tcp_port_to_client_as; es_version } -> f' [] instance_id time_stamp state is_alive http_end_point internal_tcp external_tcp internal_tcp_uses_tls external_tcp_uses_tls last_commit_position writer_checkpoint chaser_checkpoint epoch_position epoch_number epoch_id node_priority is_read_only_replica advertise_host_to_client_as advertise_http_port_to_client_as advertise_tcp_port_to_client_as es_version in
        let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic (2, int64_int, proto3) ^:: basic (3, (enum MemberInfo.VNodeState.to_int), proto3) ^:: basic (4, bool, proto3) ^:: basic_opt (5, (message (fun t -> EndPoint.to_proto t))) ^:: basic_opt (6, (message (fun t -> EndPoint.to_proto t))) ^:: basic_opt (7, (message (fun t -> EndPoint.to_proto t))) ^:: basic (8, bool, proto3) ^:: basic (9, bool, proto3) ^:: basic (10, int64_int, proto3) ^:: basic (11, int64_int, proto3) ^:: basic (12, int64_int, proto3) ^:: basic (13, int64_int, proto3) ^:: basic (14, int32_int, proto3) ^:: basic_opt (15, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.to_proto t))) ^:: basic (16, int32_int, proto3) ^:: basic (17, bool, proto3) ^:: basic (18, string, proto3) ^:: basic (19, uint32_int, proto3) ^:: basic (20, uint32_int, proto3) ^:: basic (21, string, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions instance_id time_stamp state is_alive http_end_point internal_tcp external_tcp internal_tcp_uses_tls external_tcp_uses_tls last_commit_position writer_checkpoint chaser_checkpoint epoch_position epoch_number epoch_id node_priority is_read_only_replica advertise_host_to_client_as advertise_http_port_to_client_as advertise_tcp_port_to_client_as es_version -> { instance_id; time_stamp; state; is_alive; http_end_point; internal_tcp; external_tcp; internal_tcp_uses_tls; external_tcp_uses_tls; last_commit_position; writer_checkpoint; chaser_checkpoint; epoch_position; epoch_number; epoch_id; node_priority; is_read_only_replica; advertise_host_to_client_as; advertise_http_port_to_client_as; advertise_tcp_port_to_client_as; es_version } in
        let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic (2, int64_int, proto3) ^:: basic (3, (enum MemberInfo.VNodeState.from_int), proto3) ^:: basic (4, bool, proto3) ^:: basic_opt (5, (message (fun t -> EndPoint.from_proto t))) ^:: basic_opt (6, (message (fun t -> EndPoint.from_proto t))) ^:: basic_opt (7, (message (fun t -> EndPoint.from_proto t))) ^:: basic (8, bool, proto3) ^:: basic (9, bool, proto3) ^:: basic (10, int64_int, proto3) ^:: basic (11, int64_int, proto3) ^:: basic (12, int64_int, proto3) ^:: basic (13, int64_int, proto3) ^:: basic (14, int32_int, proto3) ^:: basic_opt (15, (message (fun t -> Imported'modules.Shared.Event_store.Client.UUID.from_proto t))) ^:: basic (16, int32_int, proto3) ^:: basic (17, bool, proto3) ^:: basic (18, string, proto3) ^:: basic (19, uint32_int, proto3) ^:: basic (20, uint32_int, proto3) ^:: basic (21, string, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and ReplicaLogWrite : sig
      val name': unit -> string
      type t = { log_position: int; replica_id: bytes } 
      val make : ?log_position:int -> ?replica_id:bytes -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.ReplicaLogWrite"
      type t = { log_position: int; replica_id: bytes }
      let make =
        fun ?log_position ?replica_id () -> 
        let log_position = match log_position with Some v -> v | None -> 0 in
        let replica_id = match replica_id with Some v -> v | None -> (Bytes.of_string {||}) in
        { log_position; replica_id }
      
      let to_proto =
        let apply = fun ~f:f' { log_position; replica_id } -> f' [] log_position replica_id in
        let spec = Runtime'.Serialize.C.( basic (1, int64_int, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions log_position replica_id -> { log_position; replica_id } in
        let spec = Runtime'.Deserialize.C.( basic (1, int64_int, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and ReplicatedTo : sig
      val name': unit -> string
      type t = int 
      val make : ?log_position:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.ReplicatedTo"
      type t = int
      let make =
        fun ?log_position () -> 
        let log_position = match log_position with Some v -> v | None -> 0 in
        log_position
      
      let to_proto =
        let apply = fun ~f:f' log_position -> f' [] log_position in
        let spec = Runtime'.Serialize.C.( basic (1, int64_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions log_position -> log_position in
        let spec = Runtime'.Deserialize.C.( basic (1, int64_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and Epoch : sig
      val name': unit -> string
      type t = { epoch_position: int; epoch_number: int; epoch_id: bytes } 
      val make : ?epoch_position:int -> ?epoch_number:int -> ?epoch_id:bytes -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.Epoch"
      type t = { epoch_position: int; epoch_number: int; epoch_id: bytes }
      let make =
        fun ?epoch_position ?epoch_number ?epoch_id () -> 
        let epoch_position = match epoch_position with Some v -> v | None -> 0 in
        let epoch_number = match epoch_number with Some v -> v | None -> 0 in
        let epoch_id = match epoch_id with Some v -> v | None -> (Bytes.of_string {||}) in
        { epoch_position; epoch_number; epoch_id }
      
      let to_proto =
        let apply = fun ~f:f' { epoch_position; epoch_number; epoch_id } -> f' [] epoch_position epoch_number epoch_id in
        let spec = Runtime'.Serialize.C.( basic (1, int64_int, proto3) ^:: basic (2, int32_int, proto3) ^:: basic (3, bytes, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions epoch_position epoch_number epoch_id -> { epoch_position; epoch_number; epoch_id } in
        let spec = Runtime'.Deserialize.C.( basic (1, int64_int, proto3) ^:: basic (2, int32_int, proto3) ^:: basic (3, bytes, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and SubscribeReplica : sig
      val name': unit -> string
      type t = { log_position: int; chunk_id: bytes; lastEpochs: Epoch.t list; ip: bytes; port: int; leader_id: bytes; subscription_id: bytes; is_promotable: bool; version: int } 
      val make : ?log_position:int -> ?chunk_id:bytes -> ?lastEpochs:Epoch.t list -> ?ip:bytes -> ?port:int -> ?leader_id:bytes -> ?subscription_id:bytes -> ?is_promotable:bool -> ?version:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.SubscribeReplica"
      type t = { log_position: int; chunk_id: bytes; lastEpochs: Epoch.t list; ip: bytes; port: int; leader_id: bytes; subscription_id: bytes; is_promotable: bool; version: int }
      let make =
        fun ?log_position ?chunk_id ?lastEpochs ?ip ?port ?leader_id ?subscription_id ?is_promotable ?version () -> 
        let log_position = match log_position with Some v -> v | None -> 0 in
        let chunk_id = match chunk_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let lastEpochs = match lastEpochs with Some v -> v | None -> [] in
        let ip = match ip with Some v -> v | None -> (Bytes.of_string {||}) in
        let port = match port with Some v -> v | None -> 0 in
        let leader_id = match leader_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let is_promotable = match is_promotable with Some v -> v | None -> false in
        let version = match version with Some v -> v | None -> 0 in
        { log_position; chunk_id; lastEpochs; ip; port; leader_id; subscription_id; is_promotable; version }
      
      let to_proto =
        let apply = fun ~f:f' { log_position; chunk_id; lastEpochs; ip; port; leader_id; subscription_id; is_promotable; version } -> f' [] log_position chunk_id lastEpochs ip port leader_id subscription_id is_promotable version in
        let spec = Runtime'.Serialize.C.( basic (1, int64_int, proto3) ^:: basic (2, bytes, proto3) ^:: repeated (3, (message (fun t -> Epoch.to_proto t)), not_packed) ^:: basic (4, bytes, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, bytes, proto3) ^:: basic (7, bytes, proto3) ^:: basic (8, bool, proto3) ^:: basic (9, int32_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions log_position chunk_id lastEpochs ip port leader_id subscription_id is_promotable version -> { log_position; chunk_id; lastEpochs; ip; port; leader_id; subscription_id; is_promotable; version } in
        let spec = Runtime'.Deserialize.C.( basic (1, int64_int, proto3) ^:: basic (2, bytes, proto3) ^:: repeated (3, (message (fun t -> Epoch.from_proto t)), not_packed) ^:: basic (4, bytes, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, bytes, proto3) ^:: basic (7, bytes, proto3) ^:: basic (8, bool, proto3) ^:: basic (9, int32_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and ReplicaSubscriptionRetry : sig
      val name': unit -> string
      type t = { leader_id: bytes; subscription_id: bytes } 
      val make : ?leader_id:bytes -> ?subscription_id:bytes -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.ReplicaSubscriptionRetry"
      type t = { leader_id: bytes; subscription_id: bytes }
      let make =
        fun ?leader_id ?subscription_id () -> 
        let leader_id = match leader_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        { leader_id; subscription_id }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; subscription_id } -> f' [] leader_id subscription_id in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id subscription_id -> { leader_id; subscription_id } in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and ReplicaSubscribed : sig
      val name': unit -> string
      type t = { leader_id: bytes; subscription_id: bytes; subscription_position: int } 
      val make : ?leader_id:bytes -> ?subscription_id:bytes -> ?subscription_position:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.ReplicaSubscribed"
      type t = { leader_id: bytes; subscription_id: bytes; subscription_position: int }
      let make =
        fun ?leader_id ?subscription_id ?subscription_position () -> 
        let leader_id = match leader_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_position = match subscription_position with Some v -> v | None -> 0 in
        { leader_id; subscription_id; subscription_position }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; subscription_id; subscription_position } -> f' [] leader_id subscription_id subscription_position in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, int64_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id subscription_id subscription_position -> { leader_id; subscription_id; subscription_position } in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, int64_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and ReplicaLogPositionAck : sig
      val name': unit -> string
      type t = { subscription_id: bytes; replication_log_position: int; writer_log_position: int } 
      val make : ?subscription_id:bytes -> ?replication_log_position:int -> ?writer_log_position:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.ReplicaLogPositionAck"
      type t = { subscription_id: bytes; replication_log_position: int; writer_log_position: int }
      let make =
        fun ?subscription_id ?replication_log_position ?writer_log_position () -> 
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let replication_log_position = match replication_log_position with Some v -> v | None -> 0 in
        let writer_log_position = match writer_log_position with Some v -> v | None -> 0 in
        { subscription_id; replication_log_position; writer_log_position }
      
      let to_proto =
        let apply = fun ~f:f' { subscription_id; replication_log_position; writer_log_position } -> f' [] subscription_id replication_log_position writer_log_position in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, int64_int, proto3) ^:: basic (3, int64_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions subscription_id replication_log_position writer_log_position -> { subscription_id; replication_log_position; writer_log_position } in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, int64_int, proto3) ^:: basic (3, int64_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and CreateChunk : sig
      val name': unit -> string
      type t = { leader_id: bytes; subscription_id: bytes; chunk_header_bytes: bytes; file_size: int; is_completed_chunk: bool } 
      val make : ?leader_id:bytes -> ?subscription_id:bytes -> ?chunk_header_bytes:bytes -> ?file_size:int -> ?is_completed_chunk:bool -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.CreateChunk"
      type t = { leader_id: bytes; subscription_id: bytes; chunk_header_bytes: bytes; file_size: int; is_completed_chunk: bool }
      let make =
        fun ?leader_id ?subscription_id ?chunk_header_bytes ?file_size ?is_completed_chunk () -> 
        let leader_id = match leader_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let chunk_header_bytes = match chunk_header_bytes with Some v -> v | None -> (Bytes.of_string {||}) in
        let file_size = match file_size with Some v -> v | None -> 0 in
        let is_completed_chunk = match is_completed_chunk with Some v -> v | None -> false in
        { leader_id; subscription_id; chunk_header_bytes; file_size; is_completed_chunk }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; subscription_id; chunk_header_bytes; file_size; is_completed_chunk } -> f' [] leader_id subscription_id chunk_header_bytes file_size is_completed_chunk in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, bytes, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id subscription_id chunk_header_bytes file_size is_completed_chunk -> { leader_id; subscription_id; chunk_header_bytes; file_size; is_completed_chunk } in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, bytes, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and RawChunkBulk : sig
      val name': unit -> string
      type t = { leader_id: bytes; subscription_id: bytes; chunk_start_number: int; chunk_end_number: int; raw_position: int; raw_bytes: bytes; complete_chunk: bool } 
      val make : ?leader_id:bytes -> ?subscription_id:bytes -> ?chunk_start_number:int -> ?chunk_end_number:int -> ?raw_position:int -> ?raw_bytes:bytes -> ?complete_chunk:bool -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.RawChunkBulk"
      type t = { leader_id: bytes; subscription_id: bytes; chunk_start_number: int; chunk_end_number: int; raw_position: int; raw_bytes: bytes; complete_chunk: bool }
      let make =
        fun ?leader_id ?subscription_id ?chunk_start_number ?chunk_end_number ?raw_position ?raw_bytes ?complete_chunk () -> 
        let leader_id = match leader_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let chunk_start_number = match chunk_start_number with Some v -> v | None -> 0 in
        let chunk_end_number = match chunk_end_number with Some v -> v | None -> 0 in
        let raw_position = match raw_position with Some v -> v | None -> 0 in
        let raw_bytes = match raw_bytes with Some v -> v | None -> (Bytes.of_string {||}) in
        let complete_chunk = match complete_chunk with Some v -> v | None -> false in
        { leader_id; subscription_id; chunk_start_number; chunk_end_number; raw_position; raw_bytes; complete_chunk }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; subscription_id; chunk_start_number; chunk_end_number; raw_position; raw_bytes; complete_chunk } -> f' [] leader_id subscription_id chunk_start_number chunk_end_number raw_position raw_bytes complete_chunk in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, bytes, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id subscription_id chunk_start_number chunk_end_number raw_position raw_bytes complete_chunk -> { leader_id; subscription_id; chunk_start_number; chunk_end_number; raw_position; raw_bytes; complete_chunk } in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, bytes, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and DataChunkBulk : sig
      val name': unit -> string
      type t = { leader_id: bytes; subscription_id: bytes; chunk_start_number: int; chunk_end_number: int; subscription_position: int; data_bytes: bytes; complete_chunk: bool } 
      val make : ?leader_id:bytes -> ?subscription_id:bytes -> ?chunk_start_number:int -> ?chunk_end_number:int -> ?subscription_position:int -> ?data_bytes:bytes -> ?complete_chunk:bool -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.DataChunkBulk"
      type t = { leader_id: bytes; subscription_id: bytes; chunk_start_number: int; chunk_end_number: int; subscription_position: int; data_bytes: bytes; complete_chunk: bool }
      let make =
        fun ?leader_id ?subscription_id ?chunk_start_number ?chunk_end_number ?subscription_position ?data_bytes ?complete_chunk () -> 
        let leader_id = match leader_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let chunk_start_number = match chunk_start_number with Some v -> v | None -> 0 in
        let chunk_end_number = match chunk_end_number with Some v -> v | None -> 0 in
        let subscription_position = match subscription_position with Some v -> v | None -> 0 in
        let data_bytes = match data_bytes with Some v -> v | None -> (Bytes.of_string {||}) in
        let complete_chunk = match complete_chunk with Some v -> v | None -> false in
        { leader_id; subscription_id; chunk_start_number; chunk_end_number; subscription_position; data_bytes; complete_chunk }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; subscription_id; chunk_start_number; chunk_end_number; subscription_position; data_bytes; complete_chunk } -> f' [] leader_id subscription_id chunk_start_number chunk_end_number subscription_position data_bytes complete_chunk in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, int64_int, proto3) ^:: basic (6, bytes, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id subscription_id chunk_start_number chunk_end_number subscription_position data_bytes complete_chunk -> { leader_id; subscription_id; chunk_start_number; chunk_end_number; subscription_position; data_bytes; complete_chunk } in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, int64_int, proto3) ^:: basic (6, bytes, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and FollowerAssignment : sig
      val name': unit -> string
      type t = { leader_id: bytes; subscription_id: bytes } 
      val make : ?leader_id:bytes -> ?subscription_id:bytes -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.FollowerAssignment"
      type t = { leader_id: bytes; subscription_id: bytes }
      let make =
        fun ?leader_id ?subscription_id () -> 
        let leader_id = match leader_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        { leader_id; subscription_id }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; subscription_id } -> f' [] leader_id subscription_id in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id subscription_id -> { leader_id; subscription_id } in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and CloneAssignment : sig
      val name': unit -> string
      type t = { leader_id: bytes; subscription_id: bytes } 
      val make : ?leader_id:bytes -> ?subscription_id:bytes -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.CloneAssignment"
      type t = { leader_id: bytes; subscription_id: bytes }
      let make =
        fun ?leader_id ?subscription_id () -> 
        let leader_id = match leader_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        { leader_id; subscription_id }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; subscription_id } -> f' [] leader_id subscription_id in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id subscription_id -> { leader_id; subscription_id } in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and DropSubscription : sig
      val name': unit -> string
      type t = { leader_id: bytes; subscription_id: bytes } 
      val make : ?leader_id:bytes -> ?subscription_id:bytes -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "cluster.event_store.cluster.DropSubscription"
      type t = { leader_id: bytes; subscription_id: bytes }
      let make =
        fun ?leader_id ?subscription_id () -> 
        let leader_id = match leader_id with Some v -> v | None -> (Bytes.of_string {||}) in
        let subscription_id = match subscription_id with Some v -> v | None -> (Bytes.of_string {||}) in
        { leader_id; subscription_id }
      
      let to_proto =
        let apply = fun ~f:f' { leader_id; subscription_id } -> f' [] leader_id subscription_id in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions leader_id subscription_id -> { leader_id; subscription_id } in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    module Gossip = struct
      module Update = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Gossip"
        let method_name = "Update"
        let name = "/event_store.cluster.Gossip/Update"
        module Request = GossipRequest
        module Response = ClusterInfo
      end
      let update = 
        (module GossipRequest : Runtime'.Service.Message with type t = GossipRequest.t ), 
        (module ClusterInfo : Runtime'.Service.Message with type t = ClusterInfo.t )
      
      module Read = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Gossip"
        let method_name = "Read"
        let name = "/event_store.cluster.Gossip/Read"
        module Request = Imported'modules.Shared.Event_store.Client.Empty
        module Response = ClusterInfo
      end
      let read = 
        (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t ), 
        (module ClusterInfo : Runtime'.Service.Message with type t = ClusterInfo.t )
      
    end
    module Elections = struct
      module ViewChange = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Elections"
        let method_name = "ViewChange"
        let name = "/event_store.cluster.Elections/ViewChange"
        module Request = ViewChangeRequest
        module Response = Imported'modules.Shared.Event_store.Client.Empty
      end
      let viewChange = 
        (module ViewChangeRequest : Runtime'.Service.Message with type t = ViewChangeRequest.t ), 
        (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
      
      module ViewChangeProof = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Elections"
        let method_name = "ViewChangeProof"
        let name = "/event_store.cluster.Elections/ViewChangeProof"
        module Request = ViewChangeProofRequest
        module Response = Imported'modules.Shared.Event_store.Client.Empty
      end
      let viewChangeProof = 
        (module ViewChangeProofRequest : Runtime'.Service.Message with type t = ViewChangeProofRequest.t ), 
        (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
      
      module Prepare = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Elections"
        let method_name = "Prepare"
        let name = "/event_store.cluster.Elections/Prepare"
        module Request = PrepareRequest
        module Response = Imported'modules.Shared.Event_store.Client.Empty
      end
      let prepare = 
        (module PrepareRequest : Runtime'.Service.Message with type t = PrepareRequest.t ), 
        (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
      
      module PrepareOk = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Elections"
        let method_name = "PrepareOk"
        let name = "/event_store.cluster.Elections/PrepareOk"
        module Request = PrepareOkRequest
        module Response = Imported'modules.Shared.Event_store.Client.Empty
      end
      let prepareOk = 
        (module PrepareOkRequest : Runtime'.Service.Message with type t = PrepareOkRequest.t ), 
        (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
      
      module Proposal = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Elections"
        let method_name = "Proposal"
        let name = "/event_store.cluster.Elections/Proposal"
        module Request = ProposalRequest
        module Response = Imported'modules.Shared.Event_store.Client.Empty
      end
      let proposal = 
        (module ProposalRequest : Runtime'.Service.Message with type t = ProposalRequest.t ), 
        (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
      
      module Accept = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Elections"
        let method_name = "Accept"
        let name = "/event_store.cluster.Elections/Accept"
        module Request = AcceptRequest
        module Response = Imported'modules.Shared.Event_store.Client.Empty
      end
      let accept = 
        (module AcceptRequest : Runtime'.Service.Message with type t = AcceptRequest.t ), 
        (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
      
      module LeaderIsResigning = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Elections"
        let method_name = "LeaderIsResigning"
        let name = "/event_store.cluster.Elections/LeaderIsResigning"
        module Request = LeaderIsResigningRequest
        module Response = Imported'modules.Shared.Event_store.Client.Empty
      end
      let leaderIsResigning = 
        (module LeaderIsResigningRequest : Runtime'.Service.Message with type t = LeaderIsResigningRequest.t ), 
        (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
      
      module LeaderIsResigningOk = struct
        let package_name = Some "event_store.cluster"
        let service_name = "Elections"
        let method_name = "LeaderIsResigningOk"
        let name = "/event_store.cluster.Elections/LeaderIsResigningOk"
        module Request = LeaderIsResigningOkRequest
        module Response = Imported'modules.Shared.Event_store.Client.Empty
      end
      let leaderIsResigningOk = 
        (module LeaderIsResigningOkRequest : Runtime'.Service.Message with type t = LeaderIsResigningOkRequest.t ), 
        (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
      
    end
  end
end