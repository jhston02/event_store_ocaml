(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: projections.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Struct = Struct
  module Shared = Shared
end
(**/**)
module Event_store = struct
  module Client = struct
    module Projections = struct
      module rec CreateReq : sig
        module rec Options : sig
          module rec Transient : sig
            val name': unit -> string
            type t = string 
            val make : ?name:string -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and Continuous : sig
            val name': unit -> string
            type t = { name: string; emit_enabled: bool; track_emitted_streams: bool } 
            val make : ?name:string -> ?emit_enabled:bool -> ?track_emitted_streams:bool -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { mode: [ `not_set | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of CreateReq.Options.Transient.t | `Continuous of CreateReq.Options.Continuous.t ]; query: string } 
          val make : ?mode:[ `not_set | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of CreateReq.Options.Transient.t | `Continuous of CreateReq.Options.Continuous.t ] -> ?query:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = CreateReq.Options.t option 
        val make : ?options:CreateReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          module rec Transient : sig
            val name': unit -> string
            type t = string 
            val make : ?name:string -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          and Continuous : sig
            val name': unit -> string
            type t = { name: string; emit_enabled: bool; track_emitted_streams: bool } 
            val make : ?name:string -> ?emit_enabled:bool -> ?track_emitted_streams:bool -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end
          val name': unit -> string
          type t = { mode: [ `not_set | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of CreateReq.Options.Transient.t | `Continuous of CreateReq.Options.Continuous.t ]; query: string } 
          val make : ?mode:[ `not_set | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of CreateReq.Options.Transient.t | `Continuous of CreateReq.Options.Continuous.t ] -> ?query:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          module rec Transient : sig
            val name': unit -> string
            type t = string 
            val make : ?name:string -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "projections.event_store.client.projections.CreateReq.Options.Transient"
            type t = string
            let make =
              fun ?name () -> 
              let name = match name with Some v -> v | None -> {||} in
              name
            
            let to_proto =
              let apply = fun ~f:f' name -> f' [] name in
              let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions name -> name in
              let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          and Continuous : sig
            val name': unit -> string
            type t = { name: string; emit_enabled: bool; track_emitted_streams: bool } 
            val make : ?name:string -> ?emit_enabled:bool -> ?track_emitted_streams:bool -> unit -> t
            val to_proto: t -> Runtime'.Writer.t
            val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          end = struct 
            let name' () = "projections.event_store.client.projections.CreateReq.Options.Continuous"
            type t = { name: string; emit_enabled: bool; track_emitted_streams: bool }
            let make =
              fun ?name ?emit_enabled ?track_emitted_streams () -> 
              let name = match name with Some v -> v | None -> {||} in
              let emit_enabled = match emit_enabled with Some v -> v | None -> false in
              let track_emitted_streams = match track_emitted_streams with Some v -> v | None -> false in
              { name; emit_enabled; track_emitted_streams }
            
            let to_proto =
              let apply = fun ~f:f' { name; emit_enabled; track_emitted_streams } -> f' [] name emit_enabled track_emitted_streams in
              let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
              let serialize = Runtime'.Serialize.serialize [] (spec) in
              fun t -> apply ~f:serialize t
            
            let from_proto =
              let constructor = fun _extensions name emit_enabled track_emitted_streams -> { name; emit_enabled; track_emitted_streams } in
              let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
              let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
              fun writer -> deserialize writer |> Runtime'.Result.open_error
            
          end
          let name' () = "projections.event_store.client.projections.CreateReq.Options"
          type t = { mode: [ `not_set | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of CreateReq.Options.Transient.t | `Continuous of CreateReq.Options.Continuous.t ]; query: string }
          let make =
            fun ?mode ?query () -> 
            let mode = match mode with Some v -> v | None -> `not_set in
            let query = match query with Some v -> v | None -> {||} in
            { mode; query }
          
          let to_proto =
            let apply = fun ~f:f' { mode; query } -> f' [] mode query in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `One_time v -> oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Transient v -> oneof_elem (2, (message (fun t -> CreateReq.Options.Transient.to_proto t)), v) | `Continuous v -> oneof_elem (3, (message (fun t -> CreateReq.Options.Continuous.to_proto t)), v))) ^:: basic (4, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions mode query -> { mode; query } in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `One_time v); oneof_elem (2, (message (fun t -> CreateReq.Options.Transient.from_proto t)), fun v -> `Transient v); oneof_elem (3, (message (fun t -> CreateReq.Options.Continuous.from_proto t)), fun v -> `Continuous v) ]) ^:: basic (4, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.CreateReq"
        type t = CreateReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> CreateReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> CreateReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and CreateResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "projections.event_store.client.projections.CreateResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and UpdateReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; query: string; emit_option: [ `not_set | `Emit_enabled of bool | `No_emit_options of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?name:string -> ?query:string -> ?emit_option:[ `not_set | `Emit_enabled of bool | `No_emit_options of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = UpdateReq.Options.t option 
        val make : ?options:UpdateReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; query: string; emit_option: [ `not_set | `Emit_enabled of bool | `No_emit_options of Imported'modules.Shared.Event_store.Client.Empty.t ] } 
          val make : ?name:string -> ?query:string -> ?emit_option:[ `not_set | `Emit_enabled of bool | `No_emit_options of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "projections.event_store.client.projections.UpdateReq.Options"
          type t = { name: string; query: string; emit_option: [ `not_set | `Emit_enabled of bool | `No_emit_options of Imported'modules.Shared.Event_store.Client.Empty.t ] }
          let make =
            fun ?name ?query ?emit_option () -> 
            let name = match name with Some v -> v | None -> {||} in
            let query = match query with Some v -> v | None -> {||} in
            let emit_option = match emit_option with Some v -> v | None -> `not_set in
            { name; query; emit_option }
          
          let to_proto =
            let apply = fun ~f:f' { name; query; emit_option } -> f' [] name query emit_option in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Emit_enabled v -> oneof_elem (3, bool, v) | `No_emit_options v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions name query emit_option -> { name; query; emit_option } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: oneof ([ oneof_elem (3, bool, fun v -> `Emit_enabled v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `No_emit_options v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.UpdateReq"
        type t = UpdateReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> UpdateReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> UpdateReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and UpdateResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "projections.event_store.client.projections.UpdateResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DeleteReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; delete_emitted_streams: bool; delete_state_stream: bool; delete_checkpoint_stream: bool } 
          val make : ?name:string -> ?delete_emitted_streams:bool -> ?delete_state_stream:bool -> ?delete_checkpoint_stream:bool -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = DeleteReq.Options.t option 
        val make : ?options:DeleteReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; delete_emitted_streams: bool; delete_state_stream: bool; delete_checkpoint_stream: bool } 
          val make : ?name:string -> ?delete_emitted_streams:bool -> ?delete_state_stream:bool -> ?delete_checkpoint_stream:bool -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "projections.event_store.client.projections.DeleteReq.Options"
          type t = { name: string; delete_emitted_streams: bool; delete_state_stream: bool; delete_checkpoint_stream: bool }
          let make =
            fun ?name ?delete_emitted_streams ?delete_state_stream ?delete_checkpoint_stream () -> 
            let name = match name with Some v -> v | None -> {||} in
            let delete_emitted_streams = match delete_emitted_streams with Some v -> v | None -> false in
            let delete_state_stream = match delete_state_stream with Some v -> v | None -> false in
            let delete_checkpoint_stream = match delete_checkpoint_stream with Some v -> v | None -> false in
            { name; delete_emitted_streams; delete_state_stream; delete_checkpoint_stream }
          
          let to_proto =
            let apply = fun ~f:f' { name; delete_emitted_streams; delete_state_stream; delete_checkpoint_stream } -> f' [] name delete_emitted_streams delete_state_stream delete_checkpoint_stream in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions name delete_emitted_streams delete_state_stream delete_checkpoint_stream -> { name; delete_emitted_streams; delete_state_stream; delete_checkpoint_stream } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.DeleteReq"
        type t = DeleteReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> DeleteReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> DeleteReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DeleteResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "projections.event_store.client.projections.DeleteResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and StatisticsReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = [ `not_set | `Name of string | `All of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of Imported'modules.Shared.Event_store.Client.Empty.t | `Continuous of Imported'modules.Shared.Event_store.Client.Empty.t | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t ] 
          val make : ?mode:[ `not_set | `Name of string | `All of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of Imported'modules.Shared.Event_store.Client.Empty.t | `Continuous of Imported'modules.Shared.Event_store.Client.Empty.t | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = StatisticsReq.Options.t option 
        val make : ?options:StatisticsReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = [ `not_set | `Name of string | `All of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of Imported'modules.Shared.Event_store.Client.Empty.t | `Continuous of Imported'modules.Shared.Event_store.Client.Empty.t | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t ] 
          val make : ?mode:[ `not_set | `Name of string | `All of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of Imported'modules.Shared.Event_store.Client.Empty.t | `Continuous of Imported'modules.Shared.Event_store.Client.Empty.t | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t ] -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "projections.event_store.client.projections.StatisticsReq.Options"
          type t = [ `not_set | `Name of string | `All of Imported'modules.Shared.Event_store.Client.Empty.t | `Transient of Imported'modules.Shared.Event_store.Client.Empty.t | `Continuous of Imported'modules.Shared.Event_store.Client.Empty.t | `One_time of Imported'modules.Shared.Event_store.Client.Empty.t ]
          let make =
            fun ?mode () -> 
            let mode = match mode with Some v -> v | None -> `not_set in
            mode
          
          let to_proto =
            let apply = fun ~f:f' mode -> f' [] mode in
            let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Name v -> oneof_elem (1, string, v) | `All v -> oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Transient v -> oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `Continuous v -> oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v) | `One_time v -> oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.to_proto t)), v))) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions mode -> mode in
            let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, string, fun v -> `Name v); oneof_elem (2, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `All v); oneof_elem (3, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Transient v); oneof_elem (4, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `Continuous v); oneof_elem (5, (message (fun t -> Imported'modules.Shared.Event_store.Client.Empty.from_proto t)), fun v -> `One_time v) ]) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.StatisticsReq"
        type t = StatisticsReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> StatisticsReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> StatisticsReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and StatisticsResp : sig
        module rec Details : sig
          val name': unit -> string
          type t = { coreProcessingTime: int; version: int; epoch: int; effectiveName: string; writesInProgress: int; readsInProgress: int; partitionsCached: int; status: string; stateReason: string; name: string; mode: string; position: string; progress: float; lastCheckpoint: string; eventsProcessedAfterRestart: int; checkpointStatus: string; bufferedEvents: int; writePendingEventsBeforeCheckpoint: int; writePendingEventsAfterCheckpoint: int } 
          val make : ?coreProcessingTime:int -> ?version:int -> ?epoch:int -> ?effectiveName:string -> ?writesInProgress:int -> ?readsInProgress:int -> ?partitionsCached:int -> ?status:string -> ?stateReason:string -> ?name:string -> ?mode:string -> ?position:string -> ?progress:float -> ?lastCheckpoint:string -> ?eventsProcessedAfterRestart:int -> ?checkpointStatus:string -> ?bufferedEvents:int -> ?writePendingEventsBeforeCheckpoint:int -> ?writePendingEventsAfterCheckpoint:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = StatisticsResp.Details.t option 
        val make : ?details:StatisticsResp.Details.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Details : sig
          val name': unit -> string
          type t = { coreProcessingTime: int; version: int; epoch: int; effectiveName: string; writesInProgress: int; readsInProgress: int; partitionsCached: int; status: string; stateReason: string; name: string; mode: string; position: string; progress: float; lastCheckpoint: string; eventsProcessedAfterRestart: int; checkpointStatus: string; bufferedEvents: int; writePendingEventsBeforeCheckpoint: int; writePendingEventsAfterCheckpoint: int } 
          val make : ?coreProcessingTime:int -> ?version:int -> ?epoch:int -> ?effectiveName:string -> ?writesInProgress:int -> ?readsInProgress:int -> ?partitionsCached:int -> ?status:string -> ?stateReason:string -> ?name:string -> ?mode:string -> ?position:string -> ?progress:float -> ?lastCheckpoint:string -> ?eventsProcessedAfterRestart:int -> ?checkpointStatus:string -> ?bufferedEvents:int -> ?writePendingEventsBeforeCheckpoint:int -> ?writePendingEventsAfterCheckpoint:int -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "projections.event_store.client.projections.StatisticsResp.Details"
          type t = { coreProcessingTime: int; version: int; epoch: int; effectiveName: string; writesInProgress: int; readsInProgress: int; partitionsCached: int; status: string; stateReason: string; name: string; mode: string; position: string; progress: float; lastCheckpoint: string; eventsProcessedAfterRestart: int; checkpointStatus: string; bufferedEvents: int; writePendingEventsBeforeCheckpoint: int; writePendingEventsAfterCheckpoint: int }
          let make =
            fun ?coreProcessingTime ?version ?epoch ?effectiveName ?writesInProgress ?readsInProgress ?partitionsCached ?status ?stateReason ?name ?mode ?position ?progress ?lastCheckpoint ?eventsProcessedAfterRestart ?checkpointStatus ?bufferedEvents ?writePendingEventsBeforeCheckpoint ?writePendingEventsAfterCheckpoint () -> 
            let coreProcessingTime = match coreProcessingTime with Some v -> v | None -> 0 in
            let version = match version with Some v -> v | None -> 0 in
            let epoch = match epoch with Some v -> v | None -> 0 in
            let effectiveName = match effectiveName with Some v -> v | None -> {||} in
            let writesInProgress = match writesInProgress with Some v -> v | None -> 0 in
            let readsInProgress = match readsInProgress with Some v -> v | None -> 0 in
            let partitionsCached = match partitionsCached with Some v -> v | None -> 0 in
            let status = match status with Some v -> v | None -> {||} in
            let stateReason = match stateReason with Some v -> v | None -> {||} in
            let name = match name with Some v -> v | None -> {||} in
            let mode = match mode with Some v -> v | None -> {||} in
            let position = match position with Some v -> v | None -> {||} in
            let progress = match progress with Some v -> v | None -> 0. in
            let lastCheckpoint = match lastCheckpoint with Some v -> v | None -> {||} in
            let eventsProcessedAfterRestart = match eventsProcessedAfterRestart with Some v -> v | None -> 0 in
            let checkpointStatus = match checkpointStatus with Some v -> v | None -> {||} in
            let bufferedEvents = match bufferedEvents with Some v -> v | None -> 0 in
            let writePendingEventsBeforeCheckpoint = match writePendingEventsBeforeCheckpoint with Some v -> v | None -> 0 in
            let writePendingEventsAfterCheckpoint = match writePendingEventsAfterCheckpoint with Some v -> v | None -> 0 in
            { coreProcessingTime; version; epoch; effectiveName; writesInProgress; readsInProgress; partitionsCached; status; stateReason; name; mode; position; progress; lastCheckpoint; eventsProcessedAfterRestart; checkpointStatus; bufferedEvents; writePendingEventsBeforeCheckpoint; writePendingEventsAfterCheckpoint }
          
          let to_proto =
            let apply = fun ~f:f' { coreProcessingTime; version; epoch; effectiveName; writesInProgress; readsInProgress; partitionsCached; status; stateReason; name; mode; position; progress; lastCheckpoint; eventsProcessedAfterRestart; checkpointStatus; bufferedEvents; writePendingEventsBeforeCheckpoint; writePendingEventsAfterCheckpoint } -> f' [] coreProcessingTime version epoch effectiveName writesInProgress readsInProgress partitionsCached status stateReason name mode position progress lastCheckpoint eventsProcessedAfterRestart checkpointStatus bufferedEvents writePendingEventsBeforeCheckpoint writePendingEventsAfterCheckpoint in
            let spec = Runtime'.Serialize.C.( basic (1, int64_int, proto3) ^:: basic (2, int64_int, proto3) ^:: basic (3, int64_int, proto3) ^:: basic (4, string, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, int32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, string, proto3) ^:: basic (9, string, proto3) ^:: basic (10, string, proto3) ^:: basic (11, string, proto3) ^:: basic (12, string, proto3) ^:: basic (13, float, proto3) ^:: basic (14, string, proto3) ^:: basic (15, int64_int, proto3) ^:: basic (16, string, proto3) ^:: basic (17, int64_int, proto3) ^:: basic (18, int32_int, proto3) ^:: basic (19, int32_int, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions coreProcessingTime version epoch effectiveName writesInProgress readsInProgress partitionsCached status stateReason name mode position progress lastCheckpoint eventsProcessedAfterRestart checkpointStatus bufferedEvents writePendingEventsBeforeCheckpoint writePendingEventsAfterCheckpoint -> { coreProcessingTime; version; epoch; effectiveName; writesInProgress; readsInProgress; partitionsCached; status; stateReason; name; mode; position; progress; lastCheckpoint; eventsProcessedAfterRestart; checkpointStatus; bufferedEvents; writePendingEventsBeforeCheckpoint; writePendingEventsAfterCheckpoint } in
            let spec = Runtime'.Deserialize.C.( basic (1, int64_int, proto3) ^:: basic (2, int64_int, proto3) ^:: basic (3, int64_int, proto3) ^:: basic (4, string, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, int32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, string, proto3) ^:: basic (9, string, proto3) ^:: basic (10, string, proto3) ^:: basic (11, string, proto3) ^:: basic (12, string, proto3) ^:: basic (13, float, proto3) ^:: basic (14, string, proto3) ^:: basic (15, int64_int, proto3) ^:: basic (16, string, proto3) ^:: basic (17, int64_int, proto3) ^:: basic (18, int32_int, proto3) ^:: basic (19, int32_int, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.StatisticsResp"
        type t = StatisticsResp.Details.t option
        let make =
          fun ?details () -> 
          
          details
        
        let to_proto =
          let apply = fun ~f:f' details -> f' [] details in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> StatisticsResp.Details.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions details -> details in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> StatisticsResp.Details.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and StateReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; partition: string } 
          val make : ?name:string -> ?partition:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = StateReq.Options.t option 
        val make : ?options:StateReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; partition: string } 
          val make : ?name:string -> ?partition:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "projections.event_store.client.projections.StateReq.Options"
          type t = { name: string; partition: string }
          let make =
            fun ?name ?partition () -> 
            let name = match name with Some v -> v | None -> {||} in
            let partition = match partition with Some v -> v | None -> {||} in
            { name; partition }
          
          let to_proto =
            let apply = fun ~f:f' { name; partition } -> f' [] name partition in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions name partition -> { name; partition } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.StateReq"
        type t = StateReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> StateReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> StateReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and StateResp : sig
        val name': unit -> string
        type t = Imported'modules.Struct.Google.Protobuf.Value.t option 
        val make : ?state:Imported'modules.Struct.Google.Protobuf.Value.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "projections.event_store.client.projections.StateResp"
        type t = Imported'modules.Struct.Google.Protobuf.Value.t option
        let make =
          fun ?state () -> 
          
          state
        
        let to_proto =
          let apply = fun ~f:f' state -> f' [] state in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Struct.Google.Protobuf.Value.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions state -> state in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Struct.Google.Protobuf.Value.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ResultReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; partition: string } 
          val make : ?name:string -> ?partition:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = ResultReq.Options.t option 
        val make : ?options:ResultReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; partition: string } 
          val make : ?name:string -> ?partition:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "projections.event_store.client.projections.ResultReq.Options"
          type t = { name: string; partition: string }
          let make =
            fun ?name ?partition () -> 
            let name = match name with Some v -> v | None -> {||} in
            let partition = match partition with Some v -> v | None -> {||} in
            { name; partition }
          
          let to_proto =
            let apply = fun ~f:f' { name; partition } -> f' [] name partition in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions name partition -> { name; partition } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.ResultReq"
        type t = ResultReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ResultReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ResultReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ResultResp : sig
        val name': unit -> string
        type t = Imported'modules.Struct.Google.Protobuf.Value.t option 
        val make : ?result:Imported'modules.Struct.Google.Protobuf.Value.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "projections.event_store.client.projections.ResultResp"
        type t = Imported'modules.Struct.Google.Protobuf.Value.t option
        let make =
          fun ?result () -> 
          
          result
        
        let to_proto =
          let apply = fun ~f:f' result -> f' [] result in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Struct.Google.Protobuf.Value.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions result -> result in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Imported'modules.Struct.Google.Protobuf.Value.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ResetReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; write_checkpoint: bool } 
          val make : ?name:string -> ?write_checkpoint:bool -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = ResetReq.Options.t option 
        val make : ?options:ResetReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; write_checkpoint: bool } 
          val make : ?name:string -> ?write_checkpoint:bool -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "projections.event_store.client.projections.ResetReq.Options"
          type t = { name: string; write_checkpoint: bool }
          let make =
            fun ?name ?write_checkpoint () -> 
            let name = match name with Some v -> v | None -> {||} in
            let write_checkpoint = match write_checkpoint with Some v -> v | None -> false in
            { name; write_checkpoint }
          
          let to_proto =
            let apply = fun ~f:f' { name; write_checkpoint } -> f' [] name write_checkpoint in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions name write_checkpoint -> { name; write_checkpoint } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.ResetReq"
        type t = ResetReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ResetReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ResetReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and ResetResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "projections.event_store.client.projections.ResetResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and EnableReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = EnableReq.Options.t option 
        val make : ?options:EnableReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = string 
          val make : ?name:string -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "projections.event_store.client.projections.EnableReq.Options"
          type t = string
          let make =
            fun ?name () -> 
            let name = match name with Some v -> v | None -> {||} in
            name
          
          let to_proto =
            let apply = fun ~f:f' name -> f' [] name in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions name -> name in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.EnableReq"
        type t = EnableReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> EnableReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> EnableReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and EnableResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "projections.event_store.client.projections.EnableResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DisableReq : sig
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; write_checkpoint: bool } 
          val make : ?name:string -> ?write_checkpoint:bool -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end
        val name': unit -> string
        type t = DisableReq.Options.t option 
        val make : ?options:DisableReq.Options.t -> unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        module rec Options : sig
          val name': unit -> string
          type t = { name: string; write_checkpoint: bool } 
          val make : ?name:string -> ?write_checkpoint:bool -> unit -> t
          val to_proto: t -> Runtime'.Writer.t
          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        end = struct 
          let name' () = "projections.event_store.client.projections.DisableReq.Options"
          type t = { name: string; write_checkpoint: bool }
          let make =
            fun ?name ?write_checkpoint () -> 
            let name = match name with Some v -> v | None -> {||} in
            let write_checkpoint = match write_checkpoint with Some v -> v | None -> false in
            { name; write_checkpoint }
          
          let to_proto =
            let apply = fun ~f:f' { name; write_checkpoint } -> f' [] name write_checkpoint in
            let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: nil ) in
            let serialize = Runtime'.Serialize.serialize [] (spec) in
            fun t -> apply ~f:serialize t
          
          let from_proto =
            let constructor = fun _extensions name write_checkpoint -> { name; write_checkpoint } in
            let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: nil ) in
            let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
            fun writer -> deserialize writer |> Runtime'.Result.open_error
          
        end
        let name' () = "projections.event_store.client.projections.DisableReq"
        type t = DisableReq.Options.t option
        let make =
          fun ?options () -> 
          
          options
        
        let to_proto =
          let apply = fun ~f:f' options -> f' [] options in
          let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> DisableReq.Options.to_proto t))) ^:: nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions options -> options in
          let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> DisableReq.Options.from_proto t))) ^:: nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      and DisableResp : sig
        val name': unit -> string
        type t = unit 
        val make : unit -> t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      end = struct 
        let name' () = "projections.event_store.client.projections.DisableResp"
        type t = unit
        let make =
          fun  () -> 
          
          ()
        
        let to_proto =
          let apply = fun ~f:f' () -> f' []  in
          let spec = Runtime'.Serialize.C.( nil ) in
          let serialize = Runtime'.Serialize.serialize [] (spec) in
          fun t -> apply ~f:serialize t
        
        let from_proto =
          let constructor = fun _extensions  -> () in
          let spec = Runtime'.Deserialize.C.( nil ) in
          let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
          fun writer -> deserialize writer |> Runtime'.Result.open_error
        
      end
      module Projections = struct
        module Create = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "Create"
          let name = "/event_store.client.projections.Projections/Create"
          module Request = CreateReq
          module Response = CreateResp
        end
        let create = 
          (module CreateReq : Runtime'.Service.Message with type t = CreateReq.t ), 
          (module CreateResp : Runtime'.Service.Message with type t = CreateResp.t )
        
        module Update = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "Update"
          let name = "/event_store.client.projections.Projections/Update"
          module Request = UpdateReq
          module Response = UpdateResp
        end
        let update = 
          (module UpdateReq : Runtime'.Service.Message with type t = UpdateReq.t ), 
          (module UpdateResp : Runtime'.Service.Message with type t = UpdateResp.t )
        
        module Delete = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "Delete"
          let name = "/event_store.client.projections.Projections/Delete"
          module Request = DeleteReq
          module Response = DeleteResp
        end
        let delete = 
          (module DeleteReq : Runtime'.Service.Message with type t = DeleteReq.t ), 
          (module DeleteResp : Runtime'.Service.Message with type t = DeleteResp.t )
        
        module Statistics = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "Statistics"
          let name = "/event_store.client.projections.Projections/Statistics"
          module Request = StatisticsReq
          module Response = StatisticsResp
        end
        let statistics = 
          (module StatisticsReq : Runtime'.Service.Message with type t = StatisticsReq.t ), 
          (module StatisticsResp : Runtime'.Service.Message with type t = StatisticsResp.t )
        
        module Disable = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "Disable"
          let name = "/event_store.client.projections.Projections/Disable"
          module Request = DisableReq
          module Response = DisableResp
        end
        let disable = 
          (module DisableReq : Runtime'.Service.Message with type t = DisableReq.t ), 
          (module DisableResp : Runtime'.Service.Message with type t = DisableResp.t )
        
        module Enable = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "Enable"
          let name = "/event_store.client.projections.Projections/Enable"
          module Request = EnableReq
          module Response = EnableResp
        end
        let enable = 
          (module EnableReq : Runtime'.Service.Message with type t = EnableReq.t ), 
          (module EnableResp : Runtime'.Service.Message with type t = EnableResp.t )
        
        module Reset = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "Reset"
          let name = "/event_store.client.projections.Projections/Reset"
          module Request = ResetReq
          module Response = ResetResp
        end
        let reset = 
          (module ResetReq : Runtime'.Service.Message with type t = ResetReq.t ), 
          (module ResetResp : Runtime'.Service.Message with type t = ResetResp.t )
        
        module State = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "State"
          let name = "/event_store.client.projections.Projections/State"
          module Request = StateReq
          module Response = StateResp
        end
        let state = 
          (module StateReq : Runtime'.Service.Message with type t = StateReq.t ), 
          (module StateResp : Runtime'.Service.Message with type t = StateResp.t )
        
        module Result = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "Result"
          let name = "/event_store.client.projections.Projections/Result"
          module Request = ResultReq
          module Response = ResultResp
        end
        let result = 
          (module ResultReq : Runtime'.Service.Message with type t = ResultReq.t ), 
          (module ResultResp : Runtime'.Service.Message with type t = ResultResp.t )
        
        module RestartSubsystem = struct
          let package_name = Some "event_store.client.projections"
          let service_name = "Projections"
          let method_name = "RestartSubsystem"
          let name = "/event_store.client.projections.Projections/RestartSubsystem"
          module Request = Imported'modules.Shared.Event_store.Client.Empty
          module Response = Imported'modules.Shared.Event_store.Client.Empty
        end
        let restartSubsystem = 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t ), 
          (module Imported'modules.Shared.Event_store.Client.Empty : Runtime'.Service.Message with type t = Imported'modules.Shared.Event_store.Client.Empty.t )
        
      end
    end
  end
end